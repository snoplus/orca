//--------------------------------------------------------
// ORCMC203Model
// Created by Mark  A. Howe on Tue Aug 02 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORCMC203Model.h"
#import "ORHWWizParam.h"
#import "ORHWWizSelection.h"
#import "OHexFormatter.h"
#import "ORDataTypeAssigner.h"
#import "ORCamacCrateModel.h"
#import "ORCamacControllerCard.h"
#import "ORRateGroup.h"

#pragma mark ***External Strings
NSString* ORCMC203ModelOperationModeChanged		= @"ORCMC203ModelOperationModeChanged";
NSString* ORCMC203ModelAdcBitsChanged			= @"ORCMC203ModelAdcBitsChanged";
NSString* ORCMC203ModelHistogramModeChanged		= @"ORCMC203ModelHistogramModeChanged";
NSString* ORCMC203ModelWordSizeChanged			= @"ORCMC203ModelWordSizeChanged";
NSString* ORCMC203ModelHistogramLengthChanged	= @"ORCMC203ModelHistogramLengthChanged";
NSString* ORCMC203ModelHistogramStartChanged	= @"ORCMC203ModelHistogramStartChanged";
NSString* ORCMC203RateGroupChangedNotification  = @"ORCMC203RateGroupChangedNotification";

NSString* ORCMC203SettingsLock					= @"ORCMC203SettingsLock";

@implementation ORCMC203Model
- (id) init
{
	self = [super init];
	[self setFifoRateGroup:[[[ORRateGroup alloc] initGroup:1 groupTag:0] autorelease]];
	[fifoRateGroup setIntegrationTime:5];
	return self;
}

- (void) dealloc
{
    [fifoRateGroup quit];
    [fifoRateGroup release];
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"CMC203Card"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORCMC203Controller"];
}

#pragma mark ***Accessors
- (ORRateGroup*) fifoRateGroup
{
	return fifoRateGroup;
}
- (void) setFifoRateGroup:(ORRateGroup*)newFifoRateGroup
{
	[newFifoRateGroup retain];
	[fifoRateGroup release];
	fifoRateGroup = newFifoRateGroup;
	
    [[NSNotificationCenter defaultCenter]
	 postNotificationName:ORCMC203RateGroupChangedNotification
	 object:self];    
}

- (void) setIntegrationTime:(double)newIntegrationTime
{
	//we this here so we have undo/redo on the rate object.
    [[[self undoManager] prepareWithInvocationTarget:self] setIntegrationTime:[fifoRateGroup integrationTime]];
	[fifoRateGroup setIntegrationTime:newIntegrationTime];
}

- (int) operationMode
{
    return operationMode;
}

- (void) setOperationMode:(int)aMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setOperationMode:operationMode];
    
    operationMode = aMode;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelOperationModeChanged object:self];
}
- (int) adcBits
{
    return adcBits;
}

- (void) setAdcBits:(int)aAdcBits
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAdcBits:adcBits];
    adcBits = aAdcBits;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelAdcBitsChanged object:self];
}

- (int) histogramMode
{
    return histogramMode;
}

- (void) setHistogramMode:(int)aHistogramMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHistogramMode:histogramMode];
    histogramMode = aHistogramMode;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelHistogramModeChanged object:self];
}

- (int) wordSize
{
    return wordSize;
}

- (void) setWordSize:(int)aWordSize
{
    [[[self undoManager] prepareWithInvocationTarget:self] setWordSize:wordSize];
    wordSize = aWordSize;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelWordSizeChanged object:self];
}

- (long) histogramLength
{
    return histogramLength;
}

- (void) setHistogramLength:(long)aHistogramLength
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHistogramLength:histogramLength];
    histogramLength = aHistogramLength;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelHistogramLengthChanged object:self];
}

- (long) histogramStart
{
    return histogramStart;
}

- (void) setHistogramStart:(long)aHistogramStart
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHistogramStart:histogramStart];
    
    histogramStart = aHistogramStart;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelHistogramStartChanged object:self];
}

- (NSString*) shortName
{
	return @"CMC203";
}


- (unsigned long) histoDataId { return histoDataId; }
- (void) setHistoDataId: (unsigned long) aDataId
{
    histoDataId = aDataId;
}
- (unsigned long) fifoDataId { return fifoDataId; }
- (void) setFifoDataId: (unsigned long) aDataId
{
    fifoDataId = aDataId;
}

- (unsigned long) getCounter:(int)counterTag forGroup:(int)groupTag
{
	if(groupTag == 0){
		return fifoCount;
	}
	else return 0;
}

#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setOperationMode:[decoder decodeIntForKey:	 @"operationMode"]];
	[self setAdcBits:		 [decoder decodeIntForKey:   @"adcBits;"]];
	[self setHistogramMode:  [decoder decodeIntForKey:   @"histogramMode"]];
	[self setWordSize:		 [decoder decodeIntForKey:   @"wordSize"]];
	[self setHistogramLength:[decoder decodeInt32ForKey: @"histogramLength"]];
	[self setHistogramStart: [decoder decodeInt32ForKey: @"histogramStart"]];
    [self setFifoRateGroup:  [decoder decodeObjectForKey:@"adcRateGroup"]];
	
    if(!fifoRateGroup){
	    [self setFifoRateGroup:[[[ORRateGroup alloc] initGroup:1 groupTag:0] autorelease]];
	    [fifoRateGroup setIntegrationTime:5];
    }
    [self startRates];
    [fifoRateGroup resetRates];
    [fifoRateGroup calcRates];
	
	[[self undoManager] enableUndoRegistration];
	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeInt:	  operationMode	  forKey:@"operationMode"];
    [encoder encodeInt:	  adcBits		  forKey:@"adcBits;"];
    [encoder encodeInt:   histogramMode   forKey:@"histogramMode"];
    [encoder encodeInt:   wordSize		  forKey:@"wordSize"];
    [encoder encodeInt32: histogramLength forKey:@"histogramLength"];
    [encoder encodeInt32: histogramStart  forKey:@"histogramStart"];
    [encoder encodeObject:fifoRateGroup	  forKey:@"fifoRateGroup"];
}

#pragma mark •••HW Wizard
- (int) numberOfChannels
{
	return 0;
}
- (BOOL) hasParmetersToRamp
{
	return NO;
}

- (NSArray*) wizardParameters
{
    NSMutableArray* a = [NSMutableArray array];
	
    ORHWWizParam* p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Word Size"];
    [p setFormat:@"##0" upperLimit:1 lowerLimit:0 stepSize:1 units:@""];
    [p setSetMethod:@selector(setWordSize:) getMethod:@selector(wordSize)];
    [a addObject:p];

	p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Histogram Mode"];
    [p setFormat:@"##0" upperLimit:2 lowerLimit:0 stepSize:0 units:@""];
    [p setSetMethod:@selector(setHistogramMode:) getMethod:@selector(histogramMode)];
    [a addObject:p];
	
	p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Histogram Start"];
    [p setFormat:@"##0" upperLimit:0xffffffff lowerLimit:0 stepSize:1 units:@""];
    [p setSetMethod:@selector(setHistogramStart:) getMethod:@selector(histogramStart)];
    [a addObject:p];
	
	p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Histogram Length"];
    [p setFormat:@"##0" upperLimit:0xffffffff lowerLimit:0 stepSize:1 units:@""];
    [p setSetMethod:@selector(setHistogramLength:) getMethod:@selector(histogramLength)];
    [a addObject:p];
	
	p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Adc Resolution"];
	OHexFormatter* aFormatter = [[[OHexFormatter alloc] init] autorelease];
    [p setFormatter:aFormatter];
    [p setSetMethod:@selector(setAdcBits:) getMethod:@selector(adcBits)];
    [a addObject:p];
	
    return a;
}

- (NSArray*) wizardSelections
{
    NSMutableArray* a = [NSMutableArray array];
    [a addObject:[ORHWWizSelection itemAtLevel:kContainerLevel name:@"Crate" className:@"ORCamacCrateModel"]];
    ORHWWizSelection* s = [ORHWWizSelection itemAtLevel:kObjectLevel name:@"Station" className:@"ORCMC203Model"];
    [a addObject:s];
    return a;
	
}
- (NSNumber*) extractParam:(NSString*)param from:(NSDictionary*)fileHeader forChannel:(int)aChannel
{
	NSDictionary* cardDictionary = [self findCardDictionaryInHeader:fileHeader];
    if([param isEqualToString:@"Histogram Start"]) return [cardDictionary objectForKey:@"histogramStart"];
    else if([param isEqualToString:@"Histogram Length"]) return [cardDictionary objectForKey:@"histogramLength"];
    else if([param isEqualToString:@"Histogram Mode"]) return [cardDictionary objectForKey:@"histogramMode"];
    else if([param isEqualToString:@"Word Size"]) return [cardDictionary objectForKey:@"wordSize"];
    else if([param isEqualToString:@"Adc Resolution"]) return [cardDictionary objectForKey:@"adcBits"];
    else return nil;
}

- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{
    NSMutableDictionary* objDictionary = [super addParametersToDictionary:dictionary];
	
    [objDictionary setObject:[NSNumber numberWithLong:histogramStart]	forKey:@"histogramStart"];
    [objDictionary setObject:[NSNumber numberWithLong:histogramLength]	forKey:@"histogramLength"];	
    [objDictionary setObject:[NSNumber numberWithInt:histogramMode]		forKey:@"histogramMode"];	
    [objDictionary setObject:[NSNumber numberWithInt:wordSize]			forKey:@"wordSize"];	
    [objDictionary setObject:[NSNumber numberWithInt:adcBits]			forKey:@"adcBits"];	
    return objDictionary;
}

#pragma mark •••Hardware Access
- (void) forceFPGALoad
{
	//fpga forced load sequence
	[[self adapter] camacShortNAF:[self stationNumber] a:0 f:9];  
	[[self adapter] camacShortNAF:[self stationNumber] a:0 f:30];  
	[[self adapter] camacShortNAF:[self stationNumber] a:0 f:25]; //the A led will go out after .5 sec
	[ORTimer delay:1.0];
	[[self adapter] camacShortNAF:[self stationNumber] a:0 f:9]; 
}

- (void) initBoard
{
    @try {
		unsigned short controlReg;
		[[self adapter] camacShortNAF:[self stationNumber] a:4 f:9];  //reset everything, except Histo memory
		if(operationMode == kCMC203HistogramMode){
			[[self adapter] camacShortNAF:[self stationNumber] a:42 f:9];  //reset histo memory
			
			if(wordSize == 0)	controlReg = 0x100; //16bit histograms
			else				controlReg = 0x101; //32bit histograms
			unsigned short maxAdc = powf(2.0, (float)adcBits);
			unsigned short adcMask = maxAdc-1;
			[[self adapter] camacShortNAF:[self stationNumber] a:4 f:17 data:&adcMask];
			[[self adapter] camacShortNAF:[self stationNumber] a:5 f:17 data:&maxAdc]; 
		}
		else {
			//1MB FIFO mode
			controlReg = 0x011;
		}
		[[self adapter] camacShortNAF:[self stationNumber] a:1 f:16 data:&controlReg];  
	}
	@catch(NSException* localException) {
		NSLogError(@"CMC203",@"InitBoard",nil);
		@throw;
	}
}

- (void) stopDevice
{
	[[self adapter] camacShortNAF:[self stationNumber] a:1 f:26];
}

- (void) startDevice
{
	[[self adapter] camacShortNAF:[self stationNumber] a:1 f:24];
}

- (void) sample
{
	[self stopDevice];
	[self readHistogram];
	//tbd--store the histogram for local viewing
	[self startDevice];
}

- (NSData*) readHistogram
{
	readingHistogram = YES;
	//!!!!!Assumes that the device has been disabled
	unsigned short maxAdc = powf(2.0, (float)adcBits);								//max number of values			
	NSMutableData* histogramData = [[NSMutableData dataWithLength:(kCMC203ReservedHistoHeaderWords + maxAdc)*sizeof(long)] retain];

	unsigned short startAddress = 0;
	[[self adapter] camacShortNAF:[self stationNumber] a:1 f:17 data:&startAddress];	//load the memory start
	[[self adapter] camacShortNAF:[self stationNumber] a:5 f:17 data:&maxAdc];			//number to read
	
	int index = 0;
	unsigned long* ptr = (unsigned long*)[histogramData bytes];
	ptr[0] = histoDataId | (kCMC203ReservedHistoHeaderWords + maxAdc);
	ptr[1] = (([self crateNumber]&0xf)<<21) | (([self stationNumber]& 0x0000001f)<<16);
	[[self adapter] camacLongNAF:[self stationNumber] a:10 f:2 data:&ptr[3]];		//ls histo count
	[[self adapter] camacLongNAF:[self stationNumber] a:11 f:2 data:&ptr[4]];		//ms histo count
	while(1){
		unsigned short status = [[self adapter] camacLongNAF:[self stationNumber] a:1 f:17 data:&ptr[kCMC203ReservedHistoHeaderWords+index++]];
		if(isQbitSet(status))break;
		if(index>=maxAdc)break;
	}

	readingHistogram = NO;
	return histogramData;
}

#pragma mark •••DataTaker
- (void) setDataIds:(id)assigner
{
    histoDataId = [assigner assignDataIds:kLongForm];
    fifoDataId = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherCard
{
    [self setHistoDataId:[anotherCard histoDataId]];
    [self setFifoDataId:[anotherCard fifoDataId]];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
								 @"ORCMC203DecoderForHistogram",		@"decoder",
								 [NSNumber numberWithLong:histoDataId], @"histoDataId",
								 [NSNumber numberWithBool:YES],			@"variable",
								 [NSNumber numberWithLong:-1],			@"length",
								 nil];
    [dataDictionary setObject:aDictionary forKey:@"histogramData"];
	
    aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
								 @"ORCMC203DecoderForFifo",				@"decoder",
								 [NSNumber numberWithLong:histoDataId], @"fifoDataId",
								 [NSNumber numberWithBool:YES],			@"variable",
								 [NSNumber numberWithLong:-1],			@"length",
								 nil];
    [dataDictionary setObject:aDictionary forKey:@"fifoData"];
    return dataDictionary;
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"ORCMC203"];
}

- (void) reset
{
}

- (void) runTaskStarted:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
	
    if(![self adapter]){
		[NSException raise:@"Not Connected" format:@"You must connect to a PCI-CAMAC Controller (i.e. a CC32)."];
    }
	
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"ORCMC203Model"];    
    //----------------------------------------------------------------------------------------
	if(operationMode == kCMC203HistogramMode){
		[self clearExceptionCount];
	}
	else {
		[self startRates];
		isRunning = NO;
	}
	[self initBoard];
	[self startDevice];
}

- (void) takeData:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
	if(operationMode == kCMC203FifoMode){
		isRunning = YES;
		//read the number in the fifo
		unsigned long numInFifo=0;
		[[self adapter] camacLongNAF:[self stationNumber] a:1 f:2 data:&numInFifo];
		//read up to 512
		unsigned long dataBuffer[kCMC203ReservedFifoHeaderWords+512];
		if(numInFifo){
			unsigned long count = 0;
			do {
				unsigned long data;
				unsigned short status = [[self adapter] camacLongNAF:[self stationNumber] a:1 f:2 data:&data];
				if(!isQbitSet(status))break;
				dataBuffer[kCMC203ReservedFifoHeaderWords+count] = data;
				count++;
				fifoCount++; //for the rate
			} while(count<512);
			dataBuffer[0] = fifoDataId | kCMC203ReservedFifoHeaderWords+count;
			dataBuffer[1] = (([self crateNumber]&0xf)<<21) | (([self stationNumber]& 0x0000001f)<<16);
			[aDataPacket addLongsToFrameBuffer:dataBuffer length:kCMC203ReservedFifoHeaderWords+count];
		}
	}
	else {
		//nothing to do, histogram will be read-out at end of run
	}
}

- (void) runIsStopping:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
	if(operationMode == kCMC203HistogramMode){
		[self stopDevice];
		[aDataPacket addData:[self readHistogram]];
	}
}

- (BOOL) doneTakingData
{
	if(operationMode == kCMC203FifoMode) return YES;
	else								 return readingHistogram;
}

- (void) runTaskStopped:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
    [fifoRateGroup stop];
	isRunning = NO;
}

- (BOOL) bumpRateFromDecodeStage
{
	if(isRunning)return NO;
    
    ++fifoCount;
    return YES;
}

- (unsigned long) fifoCount
{
    return fifoCount;
}

-(void) startRates
{
	[self clearFifoCounts];
    [fifoRateGroup start:self];
}

- (void) clearFifoCounts
{
	fifoCount=0;
}

@end


