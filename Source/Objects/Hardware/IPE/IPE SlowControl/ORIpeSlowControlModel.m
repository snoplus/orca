//--------------------------------------------------------
// ORIpeSlowControlModel
// Created by Mark  A. Howe on Mon Apr 11 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORIpeSlowControlModel.h"
#import "NetSocket.h"
#import "ORDataPacket.h"
#import "ORDataTaker.h"
#import "ORSafeQueue.h"
#import "ORDataTaker.h"
#import "ORDataTypeAssigner.h"

 
#pragma mark •••Notification Strings
NSString* ORIpeSlowControlConnectAtStartChangedNotification = @"ORIpeSlowControlConnectAtStartChangedNotification";
NSString* ORIpeSlowControlAutoReconnectChangedNotification = @"ORIpeSlowControlAutoReconnectChangedNotification";
NSString* ORIpeSlowControlQueueCountChangedNotification = @"ORIpeSlowControlQueueCountChangedNotification";
NSString* ORIpeSlowControlRemotePortChangedNotification  = @"ORIpeSlowControlRemotePortChangedNotification";
NSString* ORIpeSlowControlRemoteHostChangedNotification  = @"ORIpeSlowControlRemoteHostChangedNotification";
NSString* ORIpeSlowControlIsConnectedChangedNotification = @"ORIpeSlowControlIsConnectedChangedNotification";
NSString* ORIpeSlowControlByteCountChangedNotification   = @"ORIpeSlowControlByteCountChangedNotification";
NSString* ORIpeSlowControlLock                           = @"ORIpeSlowControlLock";
//slow control -tb-
NSString* ORIpeSlowControlMonitoringFieldChangedNotification   = @"ORIpeSlowControlMonitoringFieldChangedNotification";


static NSString* ORIpeSlowControlConnector = @"ORIpeSlowControlConnector";

#define kProcessingBusy 1
#define kProcessingDone 0
#define kMaxQueueSize   10*1024

@interface ORIpeSlowControlModel (processThread)
- (void) processDataFromQueue;
- (void) process:(NSMutableData*)dataChunk;
- (void) processRecords:(NSMutableData*)dataChunk;
- (void) startProcessing;
- (void) stopProcessing;
- (void) reConnect;
@end

@interface ORIpeSlowControlModel (private)
- (void) sendRunTaskStarted:(ORDataPacket*)aDataPacket;
@end

@implementation ORIpeSlowControlModel
- (id) init
{
	self = [super init];
    readingLock = [[NSLock alloc] init];
    processLock = [[NSConditionLock alloc] init];
    currentSensor= @""; //slow control
    NSLog(@"init: self is %p, currentSensor is %p\n",self, currentSensor);
	return self;
}

- (void) dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
	[timeToStopProcessThread release];
    [processLock release];
    [readingLock release];
    [dataPacket release];
	[remoteHost release];
	[socket release];
	[dataPacket release];
	[transferQueue release];
	[currentSensor release];//slow control
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"IpeSlowControl"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORIpeSlowControlController"];
}

- (void) makeConnectors
{
    //TODO: currently we dont need a connector -tb- 2008-05-19
    return;
    ORConnector* aConnector = [[ORConnector alloc] initAt:NSMakePoint([self frame].size.width-kConnectorSize,[self frame].size.height/2 - kConnectorSize/2) withGuardian:self withObjectLink:self];
    [[self connectors] setObject:aConnector forKey:ORIpeSlowControlConnector];
    [aConnector release];
    
}

#pragma mark •••Notifications
- (void) registerNotificationObservers
{
    NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];
    notifyCenter=notifyCenter;//nonsense, just to suppress compiler warnings -tb-
    
    //TODO: currently deactivated (old Listener code) -tb- 2008-05-19
    #if 0
    [notifyCenter addObserver : self
                     selector : @selector(connectionChanged:)
                         name : ORConnectionChanged
                       object : nil];
    
    [notifyCenter addObserver : self
                     selector : @selector(documentLoaded:)
                         name : ORDocumentLoadedNotification
                       object : nil];
    #endif
    
    
}

- (void) documentLoaded:(NSNotification*)aNotification
{
    if([self objectConnectedTo:ORIpeSlowControlConnector] && connectAtStart){
        docLoaded = YES;
        [self connectSocket:YES];
    }
}

- (void) connectionChanged:(NSNotification*)aNotification
{
    if([aNotification object] == self){
        if([self objectConnectedTo:ORIpeSlowControlConnector]){
            theNextObject =  [self objectConnectedTo: ORIpeSlowControlConnector];
            if(docLoaded){
                [self connectSocket:YES];
            }
        }
        else {
            [self connectSocket:NO];
            //theNextObject = nil;
        }
    }
}


#pragma mark ***Accessors
- (BOOL) connectAtStart
{
	return connectAtStart;
}
- (void) setConnectAtStart:(BOOL)aConnectAtStart
{
	[[[self undoManager] prepareWithInvocationTarget:self] setConnectAtStart:connectAtStart];
    
	connectAtStart = aConnectAtStart;
    
	[[NSNotificationCenter defaultCenter]
		postNotificationName:ORIpeSlowControlConnectAtStartChangedNotification
                      object:self];
}
- (BOOL) autoReconnect
{
	return autoReconnect;
}
- (void) setAutoReconnect:(BOOL)aAutoReconnect
{
	[[[self undoManager] prepareWithInvocationTarget:self] setAutoReconnect:autoReconnect];
    
	autoReconnect = aAutoReconnect;
    
	[[NSNotificationCenter defaultCenter]
		postNotificationName:ORIpeSlowControlAutoReconnectChangedNotification
                      object:self];
}

- (ORSafeQueue*) transferQueue
{
	return transferQueue;
}

- (void) setTransferQueue:(ORSafeQueue*)aTransferQueue
{
	[aTransferQueue retain];
	[transferQueue release];
	transferQueue = aTransferQueue;
}

- (unsigned long) queueCount
{
	return queueCount;
}
- (void) setQueueCount:(unsigned long)aQueueCount
{
	queueCount = aQueueCount;
    
	[[NSNotificationCenter defaultCenter]
		postNotificationName:ORIpeSlowControlQueueCountChangedNotification
                      object:self];
}
- (ORDataPacket*) dataPacket
{
    return dataPacket;
}

- (void) setDataPacket:(ORDataPacket*)aDataPacket
{
    [aDataPacket retain];
    [dataPacket release];
    dataPacket = aDataPacket;
}

- (NetSocket*) socket
{
	return socket;
}
- (void) setSocket:(NetSocket*)aSocket
{
	[aSocket retain];
	[socket release];
	socket = aSocket;
    [socket setDelegate:self];
}

- (unsigned short) remotePort
{
	return remotePort;
}
- (void) setRemotePort:(unsigned short)aNewRemotePort
{
	[[[self undoManager] prepareWithInvocationTarget:self] setRemotePort:remotePort];
    
	remotePort = aNewRemotePort;
    
	[[NSNotificationCenter defaultCenter] 
			postNotificationName:ORIpeSlowControlRemotePortChangedNotification 
                          object: self];
}

- (NSString*) remoteHost
{
	return remoteHost;
}
- (void) setRemoteHost:(NSString*)aNewRemoteHost
{
    if(!aNewRemoteHost)aNewRemoteHost = @"";
    
    NSString* thisHostAdress    = [[NSHost currentHost] address];
    NSString* remoteHostAddress = [[NSHost hostWithName:aNewRemoteHost] address];
    
    if([thisHostAdress isEqualToString:remoteHostAddress]){
        aNewRemoteHost = @"";   
        NSLog(@"Sorry, you can not connect a IpeSlowControl to the local host.\n"); 
        NSLog(@"The remote host must be a different computer.\n"); 
    }
    
	[[[self undoManager] prepareWithInvocationTarget:self] setRemoteHost:remoteHost];
    
	[remoteHost autorelease];
	remoteHost = [aNewRemoteHost copy];
    
	[[NSNotificationCenter defaultCenter] 
			postNotificationName:ORIpeSlowControlRemoteHostChangedNotification 
                          object: self ];
}

- (BOOL) isConnected
{
	return isConnected;
}
- (void) setIsConnected:(BOOL)aNewIsConnected
{
	isConnected = aNewIsConnected;
    
	[[NSNotificationCenter defaultCenter] 
			postNotificationName:ORIpeSlowControlIsConnectedChangedNotification 
                          object: self ];
    
}

- (unsigned long) byteCount
{
	return byteCount;
}
- (void) setByteCount:(unsigned long)aNewByteCount
{
	byteCount = aNewByteCount;
    
	[[NSNotificationCenter defaultCenter] 
			postNotificationName:ORIpeSlowControlByteCountChangedNotification 
                          object: self ];
}

- (void) clearByteCount
{
    [self setByteCount:0];
}

- (void) incByteCount:(unsigned long)anAmount
{
    unsigned long newAmount = byteCount + anAmount;
	[self setByteCount:newAmount];
}

- (void) connectSocket:(BOOL)state
{
    if(state){
        [self setSocket:[NetSocket netsocketConnectedToHost:remoteHost port:remotePort]];
    }
    else {
        [socket close];
        [self stopProcessing];
        [self setIsConnected:[socket isConnected]];
    }
}

#pragma mark ***Slow Control Accessors
- (NSString*) currentSensor
{
    return currentSensor;
}

- (void) setCurrentSensor:(NSString*)aString
{
    if(!aString) aString=@"";
    [currentSensor autorelease];
    currentSensor=[aString copy];
}

- (int) currentSensorIntValue
{
    return currentSensorIntValue;
}
- (void) setCurrentSensorIntValue:(int)aValue
{
    currentSensorIntValue=aValue;
}


#pragma mark ***Slow Control

/** This can be tested by
  * sending out
  * [ORIpeSlowControlModel setSensorWithName:@"T007" toIntValue: 24]
  * in the Command Center , Input tab, with Send button.
  */
- (void) setSensorWithName:(NSString*)aName toIntValue:(int)aValue
{
    NSLog(@"ORIpeSlowControlModel: setSensorWithName: %@ toIntValue:%i\n",aName,aValue);
    [self setCurrentSensor:aName];
    [self setCurrentSensorIntValue:aValue];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlMonitoringFieldChangedNotification object: self ];
}


/** This can be tested by
  * sending out
  * [ORIpeSlowControlModel setSensor:"T007" toIntValue: 24]
  * in the Command Center , Input tab, with Send button.
  */
- (void) setSensor:(char*)aName toIntValue:(int)aValue  //TODO: remove it - (char*) not possible ? -tb-
{
    NSLog(@"ORIpeSlowControlModel: setSensor: %s toIntValue:%i\n",aName,aValue);
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlMonitoringFieldChangedNotification object: self ];
}


/** This can be tested by
  * sending out
  * [ORIpeSlowControlModel setSensorToIntValue: 24]
  * in the Command Center , Input tab, with Send button.
  */
- (void) setSensorToIntValue:(int)aValue
{
    NSLog(@"ORIpeSlowControlModel: setSensorToIntValue:%i\n",aValue);
    [self setCurrentSensorIntValue:aValue];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlMonitoringFieldChangedNotification object: self ];

}

#pragma mark ***Delegate Methods
- (void) netsocketConnected:(NetSocket*)inNetSocket
{
    if(inNetSocket == socket){
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(reConnect) object:nil];
        [self startProcessing];
        [self setIsConnected:[socket isConnected]];
        [self setIsConnected:YES];
    }
}

- (void) netsocket:(NetSocket*)inNetSocket dataAvailable:(unsigned)inAmount
{
    if(inNetSocket == socket){
        id theData = [socket readData];
        if(theData){
            [transferQueue enqueue:theData];
            [self incByteCount:inAmount];
        }
    }
}

- (void) netsocketDisconnected:(NetSocket*)inNetSocket
{
    if(inNetSocket == socket){
        [self stopProcessing];
        [self setIsConnected:[socket isConnected]];
        if(autoReconnect)[self performSelector:@selector(reConnect) withObject:nil afterDelay:10];
        [self setIsConnected:NO];
    }
}


#pragma mark ***Archival

- (id) initWithCoder:(NSCoder*)decoder
{

NSLog(@"initWithCoder: self before super init...: %p\n",self);
	self = [super initWithCoder:decoder];
NSLog(@"initWithCoder: self AFTER  super init...: %p\n",self);
	[[self undoManager] disableUndoRegistration];
    
	[self setRemoteHost:[decoder decodeObjectForKey:@"ORIpeSlowControlRemoteHost"]];
    [self setConnectAtStart:[decoder decodeBoolForKey:@"ConnectAtStart"]];
    [self setAutoReconnect:[decoder decodeBoolForKey:@"AutoReconnect"]];
	[self setRemotePort:[decoder decodeIntForKey:@"ORIpeSlowControlRemotePort"]];
    
    if(!currentSensor) currentSensor=@"-";
    
	[[self undoManager] enableUndoRegistration];
    
    if(remotePort==0)remotePort = 44666;
	[self registerNotificationObservers];
    readingLock = [[NSLock alloc] init];
    processLock = [[NSConditionLock alloc] init];
    
	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
	[encoder encodeObject:remoteHost forKey:@"ORIpeSlowControlRemoteHost"];
    [encoder encodeBool:connectAtStart forKey:@"ConnectAtStart"];
    [encoder encodeBool:autoReconnect forKey:@"AutoReconnect"];
	[encoder encodeInt:remotePort forKey:@"ORIpeSlowControlRemotePort"];
}


#pragma mark •••Adc or Bit Processing Protocol
- (void) startProcessCycle
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
}

- (void) endProcessCycle
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
}


- (BOOL) processValue:(int)channel
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
    
    if(channel > 15) return NO;//
    
    return YES;
}


- (void) setProcessOutput:(int)channel value:(int)value
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
}
 //not usually used, but needed for easy compatibility with the bit protocol

- (NSString*) processingTitle
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
    
    return @"IPESlowControl-TEST";
}


- (double) convertedValue:(int)channel
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
    return (double) channel;
}


- (double) maxValueForChan:(int)channel
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
    return 15.0;
}


- (double) minValueForChan:(int)channel
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
    
    return 2.0;
}


- (void) getAlarmRangeLow:(double*)theLowLimit high:(double*)theHighLimit  channel:(int)channel
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
	//	*theLowLimit = [[[chanObjs objectAtIndex:channel] objectForKey:k320ChannelLowValue] doubleValue];
//		*theHighLimit = [[[chanObjs objectAtIndex:channel] objectForKey:k320ChannelHighValue] doubleValue];
		*theLowLimit = 0.5 * ((double) channel) ;
		*theHighLimit = 2.0 * ((double) channel) ;
}


- (void)processIsStarting //not in Bit Processing Protocol, but seems to be necessary -tb-
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
}

- (void)processIsStopping //not in Bit Processing Protocol, but seems to be necessary -tb-
{
    NSLog(@"This is method: %@\n",NSStringFromSelector(_cmd));
}


@end

@implementation ORIpeSlowControlModel (processThread)
//-----------------------------------------------------------
//processDataFromQueue runs out of the processing thread
//-----------------------------------------------------------
- (void) processDataFromQueue
{
    
    if(![socket isConnected])return;
    
    if(!dataPacket){
        ORDataPacket* aDataPacket= [[ORDataPacket alloc] init];
        [self setDataPacket: aDataPacket];
        [aDataPacket release];
    }
    
    [processLock lock];
	[NSThread setThreadPriority:1.0];
	BOOL flushMessagePrintedOnce = NO;
    BOOL timeToQuit              = NO;
    threadRunning                = YES;
    do {
        NSAutoreleasePool *pool = [[NSAutoreleasePool allocWithZone:nil] init];
        [[NSRunLoop currentRunLoop] run];
        queueCount = [transferQueue count];
        if(queueCount){
			[dataToProcess appendData:[transferQueue dequeue]];
            [self process:dataToProcess];
        }
        if([timeToStopProcessThread condition]){
            queueCount = [transferQueue count];
            if(!flushMessagePrintedOnce){
                if(queueCount){
                    NSLog(@"flushing %d block%@ from listening queue\n",queueCount,(queueCount>1)?@"s ":@" ");
                }
                flushMessagePrintedOnce = YES;						
            }
            if(queueCount == 0){
                timeToQuit = YES;
            }
        }
        [pool release];
    } while(!timeToQuit);
    
	[[NSRunLoop currentRunLoop] run];
    [processLock unlockWithCondition:kProcessingDone];
    threadRunning = NO;
}

- (void) process:(NSMutableData*)dataChunk
{
	[self processRecords:dataChunk];    
}

- (void) processRecords:(NSMutableData*)dataChunk
{
    char* buffer = (char*)[dataChunk bytes];
    char* endPtr = buffer + [dataChunk length];
    
    while (buffer<endPtr) {
		NSAutoreleasePool* outerPool = [[NSAutoreleasePool allocWithZone:nil] init];
		unsigned long* lptr = (unsigned long*)buffer;
        unsigned long recordHeader = *lptr;
		unsigned long dataId = ExtractDataId(recordHeader);
		
		if(dataId == 0x00000000){
			//new style headers always have a id of zero.
			unsigned long length = ExtractLength(recordHeader)*4; //bytes
			if(buffer + length <= endPtr){
				buffer+=4;	 //point to header length
				unsigned long headerLength = *((unsigned long*)buffer); //bytes
				//we have the whole header, extract it for use
				buffer+=4;	 //point to header itself

				NSString* theHeader = [[NSString alloc] initWithBytes:buffer length:headerLength encoding:NSASCIIStringEncoding];
				[dataPacket setFileHeader:[theHeader propertyList]]; 
				[theHeader release];
                [dataPacket generateObjectLookup];
				buffer += length-4-4;
				runDataID = [[dataPacket headerObject:@"dataDescription",@"ORRunModel",@"Run",@"dataId",nil] longValue];
				
			}
		}
		else {
			BOOL endOfRun = NO;
		    while (buffer<endPtr) {
				NSAutoreleasePool* innerPool = [[NSAutoreleasePool allocWithZone:nil] init];

				//OK, regular record
				lptr = (unsigned long*)buffer;
				recordHeader = *lptr;
				dataId = ExtractDataId(recordHeader);
				unsigned long length = ExtractLength(recordHeader)*4; //bytes
				if(buffer + length <= endPtr){
					if(dataId == runDataID){
						lptr++;
						unsigned long firstWord = *lptr;
						if(!(firstWord & 0x8)){
							if(firstWord & 0x1){
								NSLog(@"IpeSlowControl: Run Start on Host: %@\n",remoteHost);
							}
							else {
								//it's an end of run record --  we have some end of run cleanup to handle
								NSLog(@"IpeSlowControl: Run Ended on Host: %@\n",remoteHost);
								//OK end of run received
								endOfRun = YES;
							}
						}
					}
					[dataPacket addData:[NSMutableData dataWithBytes:buffer length:length]];
					
					[theNextObject processData:dataPacket userInfo:nil];
					if(endOfRun){
						[self performSelectorOnMainThread:@selector(sendRunTaskStopped:) withObject:dataPacket waitUntilDone:YES];
						[dataPacket clearData];
						[self performSelectorOnMainThread:@selector(sendCloseOutRun:)    withObject:dataPacket waitUntilDone:YES];
						[self performSelectorOnMainThread:@selector(clearByteCount)      withObject:nil        waitUntilDone:YES];
					}
					[dataPacket clearData];
					buffer += length;
				}
				else {
					[innerPool release];
					break;
				}
				[innerPool release];
			}
			
			//remove processed data
			unsigned long newLength = endPtr - buffer;
			[dataToProcess replaceBytesInRange:NSMakeRange(0,(unsigned long)(endPtr-buffer)) withBytes:buffer];
			[dataToProcess setLength:newLength];
			break;
		}
		[outerPool release];
	}
}

- (void) startProcessing
{
    if(!threadRunning && [socket isConnected]){
        theNextObject =  [self objectConnectedTo: ORIpeSlowControlConnector];
        [self setByteCount:0];
        if(!transferQueue){
            [self setTransferQueue:[[[ORSafeQueue alloc] init] autorelease]];
        }
        dataToProcess = [[NSMutableData alloc] init];
        //set up the process thread control lock
        if( timeToStopProcessThread ) [ timeToStopProcessThread release ];
        timeToStopProcessThread  = [[ NSConditionLock alloc ] initWithCondition: NO ];
        
        [NSThread detachNewThreadSelector:@selector(processDataFromQueue) toTarget:self withObject:nil];
    }        
}

- (void) stopProcessing
{
    if(threadRunning){
        [timeToStopProcessThread unlockWithCondition: YES];
        
        //....wait for processing to finish.....
        //wait for the processing thread to exit.
        BOOL timeout = NO;
        NSTimeInterval t0 = [NSDate timeIntervalSinceReferenceDate];
        while(![processLock tryLockWhenCondition:kProcessingDone]){
            [NSThread sleepUntilDate:[[NSDate date] addTimeInterval:.01]];
            if([NSDate timeIntervalSinceReferenceDate]-t0 > 10){
                timeout = YES;
                threadRunning = NO;
                break;
            }
        }
        if(!timeout)[processLock unlock];
        //
        [dataToProcess release];
		dataToProcess = nil;
        [self setByteCount:0];
        [dataPacket release];
        dataPacket = nil;
        [socket readData];
    }
}

- (void) reConnect
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(reConnect) object:nil];
    [self connectSocket:YES];
}

@end

@implementation ORIpeSlowControlModel (private)
//these exist so the process thread can do some work in the main thread
- (void) sendRunTaskStarted:(ORDataPacket*)aDataPacket
{
	[theNextObject runTaskStarted:aDataPacket userInfo:nil];
}

- (void) sendRunTaskStopped:(ORDataPacket*)aDataPacket
{
	[theNextObject runTaskStopped:aDataPacket userInfo:nil];
}

- (void) sendCloseOutRun:(ORDataPacket*)aDataPacket
{
	[theNextObject closeOutRun:aDataPacket userInfo:nil];
}

@end