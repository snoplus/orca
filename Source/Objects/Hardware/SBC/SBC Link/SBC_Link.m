//--------------------------------------------------------
// SBC_Link
// Created by Mark  A. Howe on Tue Feb 07 2006
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2006 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "SBC_Link.h"
#import "SBC_Linking.h"
#import "ORFileMover.h"
#import "ORReadOutList.h"
#import "SBC_Config.h"
#import "ORTaskSequence.h"
#import "ORSafeQueue.h"
#import "ORSBC_LAMModel.h"
#import "ORCommandList.h"

#import <netdb.h>
#import <sys/types.h>
#import <sys/socket.h>
#import <sys/select.h>
#import <sys/errno.h>

#define kNoSelectionError	 0
#define kSelectionTimeout	 0
#define kNoBlock			 0
#define kBlock				 1
#define kError				-1
#define kSelectionError		-1
#define kNoData				-2

#define kSBCRateIntegrationTime 1.5

#pragma mark ***External Strings
NSString* SBC_LinkLoadModeChanged			= @"SBC_LinkLoadModeChanged";
NSString* SBC_LinkInitAfterConnectChanged	= @"SBC_LinkInitAfterConnectChanged";
NSString* SBC_LinkReloadingChanged			= @"SBC_LinkReloadingChanged";
NSString* SBC_LinkWriteValueChanged			= @"SBC_LinkWriteValueChanged";
NSString* SBC_LinkWriteAddressChanged		= @"SBC_LinkWriteAddressChanged";
NSString* SBC_LinkPathChanged				= @"SBC_LinkPathChanged";
NSString* SBC_LinkUserNameChanged			= @"SBC_LinkUserNameChanged";
NSString* SBC_LinkPassWordChanged			= @"SBC_LinkPassWordChanged";
NSString* SBC_LinkPortChanged				= @"SBC_LinkPortChanged";
NSString* SBC_LinkIPNumberChanged			= @"SBC_LinkIPNumberChanged";
NSString* SBC_LinkRunInfoChanged			= @"SBC_LinkRunInfoChanged";
NSString* SBC_LinkLock						= @"SBC_LinkLock";
NSString* SBC_LinkTimeConnectedChanged		= @"SBC_LinkTimeConnectedChanged";
NSString* SBC_LinkConnectionChanged			= @"SBC_LinkConnectionChanged";
NSString* SBC_LinkCompilerErrorsChanged		= @"SBC_LinkCompilerErrorsChanged";
NSString* SBC_LinkCompilerWarningsChanged	= @"SBC_LinkCompilerWarningsChanged";
NSString* SBC_LinkVerboseChanged			= @"SBC_LinkVerboseChanged";
NSString* SBC_LinkForceReloadChanged		= @"SBC_LinkForceReloadChanged";
NSString* SBC_LinkCrateStartStatusChanged	= @"SBC_LinkCrateStartStatusChanged";
NSString* SBC_LinkTryingToStartCrateChanged = @"SBC_LinkTryingToStartCrateChanged";
NSString* SBC_LinkByteRateChanged			= @"SBC_LinkByteRateChanged";
NSString* SBC_LinkRangeChanged				= @"SBC_LinkRangeChanged";
NSString* SBC_LinkDoRangeChanged			= @"SBC_LinkDoRangeChanged";
NSString* SBC_LinkAddressModifierChanged	= @"SBC_LinkAddressModifierChanged";
NSString* SBC_LinkRWTypeChanged             = @"SBC_LinkRWTypeChanged";
NSString* SBC_LinkInfoTypeChanged           = @"SBC_LinkInfoTypeChanged";
NSString* ORSBC_LinkPingTask				= @"ORSBC_LinkPingTask";
NSString* ORSBC_LinkCBTest					= @"ORSBC_LinkCBTest";
NSString* ORSBC_LinkNumCBTextPointsChanged	= @"ORSBC_LinkNumCBTextPointsChanged";
NSString* ORSBC_LinkNumPayloadSizeChanged	= @"ORSBC_LinkNumPayloadSizeChanged";
NSString* ORSBC_LinkJobStatus				= @"ORSBC_LinkJobStatus";
NSString* ORSBC_LinkErrorTimeOutChanged		= @"ORSBC_LinkErrorTimeOutChanged";

@implementation SBC_Link
- (id)   initWithDelegate:(ORCard*)aDelegate
{
	self = [super init];
	delegate = aDelegate; //don't retain.
	socketLock = [[NSLock alloc] init];
	
	exitCBTest    = YES;
	cbTestRunning = NO;
	[self initConnectionHistory];
	return self;
}


- (void) dealloc
{
	@try {
		[self stopCrate];
	}
	@catch (NSException* localException) {
	}
	[socketLock release];
	[eCpuDeadAlarm clearAlarm];
	[eCpuDeadAlarm release];
	[eRunFailedAlarm clearAlarm];
	[eRunFailedAlarm release];
    [timeConnected release];
	[connectionHistory release];
    [filePath release];
    [userName release];
    [passWord release];
    [IPNumber release];
	[lastQueUpdate release];

	NSString* folder = [mainStagingFolder stringByExpandingTildeInPath];
	[[NSFileManager defaultManager] removeItemAtPath:folder error:nil];
	[mainStagingFolder release];
	
	[super dealloc];
}


- (void) wakeUp 
{
	[self performSelector:@selector(calculateRates) withObject:self afterDelay:kSBCRateIntegrationTime];
}

- (void) sleep 	
{	
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(calculateRates) object:nil];
}

- (void) initConnectionHistory
{
	ipNumberIndex = [[NSUserDefaults standardUserDefaults] integerForKey: [NSString stringWithFormat:@"orca.%@.%d.IPNumberIndex",[self className],[self slot]]];
	if(!connectionHistory){
		NSArray* his = [[NSUserDefaults standardUserDefaults] objectForKey: [NSString stringWithFormat:@"orca.%@.%d.ConnectionHistory",[self className],[self slot]]];
		connectionHistory = [his mutableCopy];
	}
	if(!connectionHistory)connectionHistory = [[NSMutableArray alloc] init];
}

#pragma mark ***Accessors
- (void) clearHistory
{
	[connectionHistory release];
	connectionHistory = nil;
	
	[self setIPNumber:[self IPNumber]];
}


- (unsigned) connectionHistoryCount
{
	return [connectionHistory count];
}

- (id) connectionHistoryItem:(unsigned)index
{
	if(connectionHistory && index>=0 && index<[connectionHistory count])return [connectionHistory objectAtIndex:index];
	else return nil;
}

- (unsigned) ipNumberIndex
{
	return ipNumberIndex;
}

- (int) slot
{
	return [delegate slot];
}

- (void) setErrorTimeOut:(int)aValue
{
	[[[self undoManager] prepareWithInvocationTarget:self] setErrorTimeOut:errorTimeOut];
    errorTimeOut = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkErrorTimeOutChanged object:self];
}

- (int) errorTimeOut
{
	return errorTimeOut;
}

- (int) errorTimeOutSeconds
{
	static int translatedTimeOut[4] = {2,10,60,0};
	if(errorTimeOut<0 || errorTimeOut>3)return 2;
	else return translatedTimeOut[errorTimeOut];
}

- (int) numTestPoints
{
	return numTestPoints;
}

- (void) setNumTestPoints:(int)num
{
	if(num<1) num = 1;
	else if(num>100)num = 100;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setNumTestPoints:numTestPoints];
    
    numTestPoints = num;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkNumCBTextPointsChanged object:self];
}

- (int) infoType
{
	return infoType;
}

- (void) setInfoType:(int)aType;
{
    [[[self undoManager] prepareWithInvocationTarget:self] setInfoType:infoType];
    
    infoType = aType;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkInfoTypeChanged object:self];
}

- (void) setDelegate:(ORCard*)aDelegate
{
	delegate = aDelegate;
}

- (id) delegate
{
	return  delegate;
}

- (NSUndoManager*) undoManager
{
	return [[NSApp delegate] undoManager];
}

- (NSString*) sbcLockName
{
	return [delegate sbcLockName];
}

- (void) installDriver:(NSString*)rootPwd 
{ 
	if([delegate respondsToSelector:@selector(driverScriptName)]){
		ORTaskSequence* aSequence;	
		aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
		NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
		
		NSString* driverCodePath;
		if(loadMode)driverCodePath = [filePath stringByAppendingPathComponent:[delegate sbcLocalCodePath]];
		else driverCodePath = [resourcePath stringByAppendingPathComponent:[delegate codeResourcePath]];
		driverCodePath = [driverCodePath stringByAppendingPathComponent:[delegate driverScriptName]];
		driverScriptFileMover = [[ORFileMover alloc] init];
		[driverScriptFileMover doNotUseTempFile];
		[driverScriptFileMover setDelegate:aSequence];
		
		[driverScriptFileMover setMoveParams:[driverCodePath stringByExpandingTildeInPath]
										to:@"" 
								remoteHost:IPNumber 
								  userName:userName 
								  passWord:passWord];
		[driverScriptFileMover setVerbose:YES];
		[driverScriptFileMover doNotMoveFilesToSentFolder];
		[driverScriptFileMover setTransferType:eUseSCP];
		[aSequence addTaskObj:driverScriptFileMover];
		
		NSString* scriptRunPath = [NSString stringWithFormat:@"/home/%@/%@",userName,[delegate driverScriptName]];
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:@"root",rootPwd,IPNumber,scriptRunPath,nil]];
		
		[aSequence launch];
	/*
		ORTaskSequence* aSequence;	
		NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
		aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
		NSString* scriptPath = 
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:@"root",rootPwd,IPNumber,scriptPath,@"upgrade",nil]];
		
		[aSequence setVerbose:YES];
		[aSequence setTextToDelegate:YES];

		[aSequence launch];
*/
	}
}

- (NSString*) driverScriptName 
{
	if([delegate respondsToSelector:@selector(driverScriptName)]){
		return [delegate driverScriptName];
	}
	else return @"";
}

- (NSString*) driverScriptInfo 
{
	if([delegate respondsToSelector:@selector(driverScriptInfo)]){
		return [delegate driverScriptInfo];
	}
	else return @"";
}

- (int) loadMode
{
    return loadMode;
}

- (void) setLoadMode:(int)aLoadMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLoadMode:loadMode];
    
    loadMode = aLoadMode;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkLoadModeChanged object:self];
}

- (BOOL) initAfterConnect
{
    return initAfterConnect;
}

- (void) setInitAfterConnect:(BOOL)aInitAfterConnect
{
    [[[self undoManager] prepareWithInvocationTarget:self] setInitAfterConnect:initAfterConnect];
    
    initAfterConnect = aInitAfterConnect;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkInitAfterConnectChanged object:self];
}

- (BOOL) tryingToStartCrate
{
	return tryingTostartCrate;
}

- (void) setTryingToStartCrate:(BOOL)flag
{
	tryingTostartCrate = flag;
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkTryingToStartCrateChanged object:self];
	
}

- (BOOL) verbose
{
    return verbose;
}

- (void) setVerbose:(BOOL)flag
{
    [[[self undoManager] prepareWithInvocationTarget:self] setVerbose:verbose];
	
    verbose = flag;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkVerboseChanged object:self];
}


- (BOOL) forceReload
{
    return forceReload;
}

- (void) setForceReload:(BOOL)flag
{
    [[[self undoManager] prepareWithInvocationTarget:self] setForceReload:forceReload];
	
    forceReload = flag;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkForceReloadChanged object:self];
}

- (BOOL) reloading
{
    return reloading;
}

- (void) setReloading:(BOOL)aReloading
{
    reloading = aReloading;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkReloadingChanged object:self];
}

- (BOOL) goScriptFailed
{
    return goScriptFailed;
}

- (void) setGoScriptFailed:(BOOL)aGoScriptFailed
{
    goScriptFailed = aGoScriptFailed;
}	

- (void) setCompilerErrors:(int)aValue
{
    compilerErrors = aValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCompilerErrorsChanged object:self];
}

- (int) compilerErrors
{
	return compilerErrors;
}

- (void) setCompilerWarnings:(int)aValue
{
    compilerWarnings = aValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCompilerWarningsChanged object:self];
}

- (int) compilerWarnings
{
	return compilerWarnings;
}

- (NSDate*) lastQueUpdate
{
	return lastQueUpdate;
}
- (void) setLastQueUpdate:(NSDate*)aDate
{
	[aDate retain];
	[lastQueUpdate release];
	lastQueUpdate = aDate;
}

- (SBC_info_struct) runInfo
{
	return runInfo;
}

- (unsigned long) writeValue
{
    return writeValue;
}

- (void) setWriteValue:(unsigned long)aWriteValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setWriteValue:writeValue];
    
    writeValue = aWriteValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkWriteValueChanged object:self];
}

- (unsigned long) writeAddress
{
    return writeAddress;
}

- (void) setWriteAddress:(unsigned long)aAddress
{
    [[[self undoManager] prepareWithInvocationTarget:self] setWriteAddress:writeAddress];
    
    writeAddress = aAddress;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkWriteAddressChanged object:self];
}

- (NSString*) filePath
{
	if(!filePath)return @"";
    else return filePath;
}

- (void) setFilePath:(NSString*)aPath
{
	if(!aPath)aPath = @"~/Dev/Orca";
    [[[self undoManager] prepareWithInvocationTarget:self] setFilePath:filePath];
    
    [filePath autorelease];
    filePath = [aPath copy];    
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkPathChanged object:self];
}

- (NSString*) userName
{
	if(!userName)return @"";
    else return userName;
}

- (void) setUserName:(NSString*)aUserName
{
	if(!aUserName)aUserName = @"";
    [[[self undoManager] prepareWithInvocationTarget:self] setUserName:userName];
    
    [userName autorelease];
    userName = [aUserName copy];    
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkUserNameChanged object:self];
}

- (NSString*) passWord
{
	if(!passWord)return @"";
    else return passWord;
}

- (void) setPassWord:(NSString*)aPassWord
{
	if(!aPassWord)aPassWord = @"";
    [[[self undoManager] prepareWithInvocationTarget:self] setPassWord:passWord];
    
    [passWord autorelease];
    passWord = [aPassWord copy];    
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkPassWordChanged object:self];
}

- (int) portNumber
{
	if(portNumber ==0)portNumber = 44667;
    return portNumber;
}

- (BOOL) isConnected
{
	return isConnected;
}

- (void) setIsConnected:(BOOL)aNewIsConnected
{
	isConnected = aNewIsConnected;
	[[NSNotificationCenter defaultCenter] 
	 postNotificationName:SBC_LinkConnectionChanged 
	 object: self];
	
	[self setTimeConnected:isConnected?[NSCalendarDate date]:nil];
}

- (NSCalendarDate*) timeConnected
{
	return timeConnected;
}

- (void) setTimeConnected:(NSCalendarDate*)newTimeConnected
{
	[timeConnected autorelease];
	timeConnected=[newTimeConnected retain];	
	[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkTimeConnectedChanged object:self];
}

- (void) setPortNumber:(int)aPort
{
	if(aPort == 0) aPort = 44667; //default
    [[[self undoManager] prepareWithInvocationTarget:self] setPortNumber:portNumber];
    
    portNumber = aPort;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkPortChanged object:self];
}

- (NSString*) IPNumber
{
	if(!IPNumber)return @"";
    return IPNumber;
}

- (void) setIPNumber:(NSString*)aIPNumber
{
	if([aIPNumber length]){
		
		[[[self undoManager] prepareWithInvocationTarget:self] setIPNumber:IPNumber];
		
		[IPNumber autorelease];
		IPNumber = [aIPNumber copy];    
		
		if(!connectionHistory)connectionHistory = [[NSMutableArray alloc] init];
		if(![connectionHistory containsObject:IPNumber]){
			[connectionHistory addObject:IPNumber];
		}
		ipNumberIndex = [connectionHistory indexOfObject:aIPNumber];
			
		[[NSUserDefaults standardUserDefaults] setObject:connectionHistory forKey:[NSString stringWithFormat:@"orca.%@.%d.ConnectionHistory",[self className],[self slot]]];
		[[NSUserDefaults standardUserDefaults] setInteger:ipNumberIndex forKey:[NSString stringWithFormat:@"orca.%@.%d.IPNumberIndex",[self className],[self slot]]];
		[[NSUserDefaults standardUserDefaults] synchronize];
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkIPNumberChanged object:self];
	}
}

- (void) calculateRates
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(calculateRates) object:nil];
	[self setByteRateSent: bytesSent/kSBCRateIntegrationTime];
	[self setByteRateReceived: bytesReceived/kSBCRateIntegrationTime];
	bytesReceived = 0;
	bytesSent = 0;
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkByteRateChanged object:self];
	[self performSelector:@selector(calculateRates) withObject:nil afterDelay:kSBCRateIntegrationTime];
}

- (void) setByteRateSent:(float)aRate
{    
	byteRateSent = aRate/(float)kSBCRateIntegrationTime;
}

- (float)byteRateSent
{
	return byteRateSent;
}

- (void) setByteRateReceived:(float)aRate
{    
	byteRateReceived = aRate/(float)kSBCRateIntegrationTime;
}

- (float)byteRateReceived
{
	return byteRateReceived;
}

- (unsigned short) range
{
    return range;
}

- (void) setRange:(unsigned short)aRange
{
    [[[self undoManager] prepareWithInvocationTarget:self] setRange:range];
    
    range = aRange;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkRangeChanged object:self];
}

- (BOOL) doRange
{
    return doRange;
}

- (void) setDoRange:(BOOL)aDoRange
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDoRange:doRange];
    
    doRange = aDoRange;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkDoRangeChanged object:self];
}


- (unsigned int) readWriteType
{
    return readWriteType;
}

- (void) setReadWriteType:(unsigned int)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setReadWriteType:readWriteType];
    readWriteType = aValue;
    [[NSNotificationCenter defaultCenter]
	 postNotificationName:SBC_LinkRWTypeChanged
	 object:self];
}

- (unsigned long) addressModifier
{
    return addressModifier;
}

- (void) setAddressModifier:(unsigned long)aValue
{
	if(aValue == 0)aValue = 0x29; //default
    [[[self undoManager] prepareWithInvocationTarget:self] setAddressModifier:addressModifier];
    addressModifier = aValue;
    [[NSNotificationCenter defaultCenter]
	 postNotificationName:SBC_LinkAddressModifierChanged
	 object:self];
}

- (ORSBCLinkJobStatus*) jobStatus
{
	return jobStatus;
}

- (void) setJobStatus:(ORSBCLinkJobStatus*)theJobStatus
{
	[theJobStatus retain];
	[jobStatus release];
	jobStatus = theJobStatus;
	
	[[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkJobStatus 
														object:jobDelegate 
													  userInfo:[NSDictionary dictionaryWithObject:jobStatus forKey:@"jobStatus"]];
	
}

#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super init];
	[[self undoManager] disableUndoRegistration];
	
	[self initConnectionHistory];
	
	int num = [decoder decodeIntForKey:   @"numTestPoints"];
	if(num == 0) [self setNumTestPoints:20];
	else [self setNumTestPoints:num];
	
	long lnum = [decoder decodeInt32ForKey:  @"payloadSize"];
	if(lnum==0)[self setPayloadSize:65000];
	else [self setPayloadSize:lnum];


	[self setInfoType:		[decoder decodeIntForKey:   @"infoType"]];
	[self setLoadMode:		[decoder decodeIntForKey:   @"loadMode"]];
	[self setInitAfterConnect:[decoder decodeBoolForKey:@"InitAfterConnect"]];
	[self setWriteValue:	[decoder decodeInt32ForKey: @"WriteValue"]];
	[self setWriteAddress:	[decoder decodeInt32ForKey: @"WriteAddress"]];
	[self setFilePath:		[decoder decodeObjectForKey:@"FilePath"]];
	[self setUserName:		[decoder decodeObjectForKey:@"UserName"]];
	[self setPassWord:		[decoder decodeObjectForKey:@"PassWord"]];
	[self setPortNumber:	[decoder decodeIntForKey:   @"PortNumber"]];
	[self setIPNumber:		[decoder decodeObjectForKey:@"IPNumber"]];
	[self setVerbose:		[decoder decodeBoolForKey:	@"Verbose"]];
	[self setForceReload:	[decoder decodeBoolForKey:	@"ForceReload"]];
    [self setRange:			[decoder decodeIntForKey:	@"Range"]];
    [self setDoRange:		[decoder decodeBoolForKey:	@"DoRange"]];
    [self setReadWriteType: [decoder decodeIntForKey:   @"ReadWriteType"]];	
    [self setAddressModifier: [decoder decodeIntForKey:   @"addressModifier"]];	
    [self setErrorTimeOut:  [decoder decodeIntForKey:   @"errorTimeOut"]];	
	socketLock = [[NSLock alloc] init];
	
	exitCBTest    = YES;
	cbTestRunning = NO;

	[[self undoManager] enableUndoRegistration];
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [encoder encodeInt32:payloadSize	forKey:@"payloadSize"];
    [encoder encodeInt:numTestPoints	forKey:@"numTestPoints"];
    [encoder encodeInt:infoType			forKey:@"infoType"];
    [encoder encodeInt:range			forKey:@"Range"];
    [encoder encodeBool:doRange			forKey:@"DoRange"];
	[encoder encodeInt:loadMode			forKey:@"loadMode"];
	[encoder encodeBool:initAfterConnect forKey:@"InitAfterConnect"];
	[encoder encodeInt32:writeValue		forKey:@"WriteValue"];
	[encoder encodeInt32:writeAddress	forKey:@"WriteAddress"];
	[encoder encodeObject:filePath		forKey:@"FilePath"];
	[encoder encodeObject:userName		forKey:@"UserName"];
	[encoder encodeObject:passWord		forKey:@"PassWord"];
	[encoder encodeInt:portNumber		forKey:@"PortNumber"];
	[encoder encodeObject:IPNumber		forKey:@"IPNumber"];
	[encoder encodeBool:verbose			forKey:@"Verbose"];
	[encoder encodeBool:forceReload		forKey:@"ForceReload"];
    [encoder encodeInt:readWriteType    forKey:@"ReadWriteType"];
    [encoder encodeInt:addressModifier    forKey:@"addressModifier"];
    [encoder encodeInt:errorTimeOut    forKey:@"errorTimeOut"];
}


- (void) fileMoverIsDone:(NSNotification*)aNote
{
	if([aNote object] == SBCFileMover){
		NSLog(@"Transfered Core SBC Code: %@ to %@\n",[SBCFileMover fileName],[SBCFileMover remoteHost]);
		[SBCFileMover release];
		SBCFileMover  = nil;
		NSString* folder = [mainStagingFolder stringByExpandingTildeInPath];
		[[NSFileManager defaultManager] removeItemAtPath:folder error:nil];
		[mainStagingFolder release];
		mainStagingFolder= nil;
	}
	
	else if([aNote object] == driverScriptFileMover){
		NSLog(@"Transfered Driver Update Script: %@ to %@\n",[driverScriptFileMover fileName],[driverScriptFileMover remoteHost]);
		[driverScriptFileMover release];
		driverScriptFileMover  = nil;
	}
}

- (void) tasksCompleted:(id)sender
{
	if(reloading){
		NSString* aCrateName = [self crateName];
		NSLog(@"%@  %d: reload done\n",aCrateName,[delegate crateNumber]);
		[self setReloading:NO];
		if(compilerErrors == 0 && compilerWarnings == 0){
			NSLog(@"%@: %d loaded and compiled without errors\n",aCrateName,[delegate crateNumber]);
		}
		if(compilerErrors){
			NSLogColor([NSColor redColor],@"%@: %d didn't compile\n",aCrateName,[delegate crateNumber]);
		}
		if(compilerWarnings && !compilerErrors){
			NSLogColor([NSColor redColor],@"%@: %d compiled with %d warnings\n",aCrateName,[self compilerWarnings],[delegate crateNumber]);
		}
		[self setCompilerErrors:0];
		[self setCompilerWarnings:0];
		
		[self performSelector:@selector(startCrateCode) withObject:self afterDelay:0];
	}
}

- (void) getRunInfoBlock
{
	SBC_Packet aPacket;
	aPacket.cmdHeader.destination			= kSBC_Process;
	aPacket.cmdHeader.cmdID					= kSBC_RunInfoRequest;
	aPacket.cmdHeader.numberBytesinPayload	= 0;
	
	[self send:&aPacket receive:&aPacket];
	
	memcpy(&runInfo,aPacket.payload,sizeof(SBC_info_struct));
	
	[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkRunInfoChanged object:self];
}

- (unsigned long) throttle
{
	return throttle;
}
- (void) reloadClient
{
	[self setReloading:YES];
	[self setCompilerErrors:0];
	[self setCompilerWarnings:0];
	//this loads an entire copy of the client code onto the remote server and does a make.
	//it does NOT start the code
    if(portNumber){
		@try {
			[self stopCrate];
		}
		@catch (NSException* localException) {
			NSLog(@"Could not stop crate ... Probably already stopped\n");
		}
		NSLog(@"Core code for crate reload starting\n");
		
		//get the core and hw specific paths
		NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
		
		NSString* coreCodePath;
		if(loadMode) coreCodePath = [filePath stringByAppendingPathComponent:@"Source/Objects/Hardware/SBC/SBC_Code"];
		else		 coreCodePath = [resourcePath stringByAppendingPathComponent:@"SBC_Code"];
		
		NSString* hwSpecificCodePath;
		if(loadMode)hwSpecificCodePath = [filePath stringByAppendingPathComponent:[delegate sbcLocalCodePath]];
		else hwSpecificCodePath = [resourcePath stringByAppendingPathComponent:[delegate codeResourcePath]];
		
		//make a staging area
		NSString* stagingFolder = [[ApplicationSupport sharedApplicationSupport] applicationSupportFolder:@"Staging"];
		char* tmpName = tempnam([stagingFolder cStringUsingEncoding:NSASCIIStringEncoding] , [[hwSpecificCodePath lastPathComponent] cStringUsingEncoding:NSASCIIStringEncoding]);
		mainStagingFolder = [[NSString stringWithCString:tmpName encoding:NSASCIIStringEncoding] retain];
		free(tmpName);
		NSFileManager* fm = [NSFileManager defaultManager];
		[fm createDirectoryAtPath:mainStagingFolder withIntermediateDirectories:YES attributes:nil error:nil];
		
		//copy all files to the staging area
		NSString* srcFolder        = [hwSpecificCodePath stringByExpandingTildeInPath];
		NSArray* filesToStage      = [fm contentsOfDirectoryAtPath:srcFolder error:nil];
		NSString* driverScriptFile = [delegate driverScriptName];
		
		for(id aFile in filesToStage){
			if(![aFile isEqual:@".svn"] && ![aFile isEqual:driverScriptFile]){
				NSString* srcFile = [srcFolder stringByAppendingPathComponent:aFile];
				NSString* desFile = [mainStagingFolder stringByAppendingPathComponent:aFile];
				[fm copyItemAtPath:srcFile toPath:desFile error:nil];
			}
		}
		
		srcFolder    = [coreCodePath stringByExpandingTildeInPath];
		filesToStage = [fm contentsOfDirectoryAtPath:srcFolder error:nil];
		for(id aFile in filesToStage){
			if(![aFile isEqual:@".svn"]){
				NSString* srcFile = [srcFolder stringByAppendingPathComponent:aFile];
				NSString* desFile = [mainStagingFolder stringByAppendingPathComponent:aFile];
				[fm copyItemAtPath:srcFile toPath:desFile error:nil];
			}
		}
		//edit the scripts
		[self fillInScript:@"makeScript"];
		[self fillInScript:@"goScript"];
				 
		//ship the files from the staging area
		ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
		[aSequence setVerbose:verbose];
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:userName,passWord,IPNumber,@"/bin/rm",@"-rf",@"ORCA",nil]];
		[aSequence setTextToDelegate:YES];
		
		SBCFileMover = [[ORFileMover alloc] init];
		[SBCFileMover doNotUseTempFile];
		[SBCFileMover setDelegate:aSequence];
		[SBCFileMover setMoveParams:[mainStagingFolder stringByExpandingTildeInPath]
									 to:@"ORCA" 
							 remoteHost:IPNumber 
							   userName:userName 
							   passWord:passWord];
		[SBCFileMover setVerbose:NO];
		[SBCFileMover doNotMoveFilesToSentFolder];
		[SBCFileMover setTransferType:eUseSCP];
		[aSequence addTaskObj:SBCFileMover];
		
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:userName,passWord,IPNumber,@"~/ORCA/makeScript",nil]];
		
		[aSequence launch];
	}
}

- (void) killCrate
{
	@try {
		startCrateState = kDone;
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCrateStartStatusChanged object:self];
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(startCrateProcess) object:nil];
		[self stopCrate];
	}
	@catch (NSException* localException) {
	}
		
	NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
	ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
	[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
			 arguments:[NSArray arrayWithObjects:userName,passWord,IPNumber,@"~/ORCA/killScript",nil]];
	
	[aSequence setVerbose:verbose];
	[aSequence setTextToDelegate:YES];
	
	[aSequence launch];
}


- (void) taskFinished:(NSTask*)aTask
{
	if(aTask == pingTask){
		[pingTask release];
		pingTask = nil;
		[[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkPingTask object:self];
	}
}

- (void) taskData:(NSString*)text
{
	if([text rangeOfString:@"error:"].location!=NSNotFound){
		[self setCompilerErrors:compilerErrors+1];
		NSLogColor([NSColor redColor], @"%@\n",text);
	}
	else if([text rangeOfString:@"warning"].location!=NSNotFound){
		[self setCompilerWarnings:compilerWarnings+1];
		NSLogColor([NSColor redColor], @"%@\n",text);
	}
	else if([text rangeOfString:@"goScript:"].location != NSNotFound){
		[self setGoScriptFailed:YES];
		NSLogColor([NSColor redColor], @"%@\n",text);
	}
	else if([text rangeOfString:@"min/avg/max/stddev"].location!=NSNotFound){
		NSScanner* scanner = [NSScanner scannerWithString:text];
		[scanner scanUpToString:@"min/avg/max/stddev" intoString:nil];
		[scanner scanUpToString:@"=" intoString:nil];
		[scanner scanUpToString:@"/" intoString:nil];
		[scanner setScanLocation:[scanner scanLocation]+1];
		NSString* ave;
		[scanner scanUpToString:@"/" intoString:&ave];
		NSLog(@"ave: %.3f ms\n",[ave floatValue]);
	}
}

- (void) toggleCrate
{
	if([self isConnected]){
		@try {
			[self stopCrate];
		}
		@catch (NSException* localException) {
			[self disconnect];
		}
	}
	else {
		[self setTryingToStartCrate:YES];
		if(forceReload){
			startCrateState = kReloadCode;
		}
		else {
			startCrateState = kTryToConnect;
		}
		[self performSelector:@selector(startCrateProcess) withObject:self afterDelay:0];
	}
}

- (void) startCrate
{
	if(!tryingTostartCrate){		
		[self setTryingToStartCrate:YES];
		startCrateState = kTryToConnect;
		[self performSelector:@selector(startCrateProcess) withObject:self afterDelay:0];
	}
}

- (void) stopCrate
{
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future run options could be added here.
		optionBlock.option[i]	= 0;
	}
	[self sendCommand:kSBC_Exit withOptions:&optionBlock  expectResponse:NO];
	[self disconnect];
}

- (void) startCrateCode
{
	[self setGoScriptFailed:NO];
	NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
	ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
	[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
			 arguments:[NSArray arrayWithObjects:userName,passWord,IPNumber,@"~/ORCA/goScript",nil]];

	[aSequence setVerbose:verbose];
	[aSequence setTextToDelegate:YES];
	
	[aSequence launch];
}

- (void) shutDown:(NSString*)rootPwd reboot:(BOOL)reboot
{
	[self disconnect];
	[self setGoScriptFailed:NO];
	NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
	ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
	if(reboot){
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:@"root",rootPwd,IPNumber,@"shutdown",@"-r",@"now",nil]];
	}
	else {
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:@"root",rootPwd,IPNumber,@"shutdown",@"-h",@"now",nil]];
	}
	[aSequence setVerbose:verbose];
	[aSequence setTextToDelegate:YES];
	
	[aSequence launch];
	
}

- (void) tellClientToStartRun
{
	
	[self sendPayloadSize:65000];
	
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future run options could be added here.
		optionBlock.option[i]	= 0;
	}
	
	[self sendCommand:kSBC_StartRun withOptions:&optionBlock expectResponse:YES];
	
	if(optionBlock.option[0] == 1){
		isRunning = YES;
	}
	else {
		isRunning = NO;
		[NSException raise:@"Run Didn't Start" format:@"%@ failed to start run",[self crateName]];	
	}
}

- (void) tellClientToStopRun
{
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future run options could be added here.
		optionBlock.option[i]	= 0;
	}
	
	[self sendCommand:kSBC_StopRun withOptions:&optionBlock expectResponse:YES];
	
	if(optionBlock.option[0] == 0){
		isRunning = NO;
	}
	else {
		[NSException raise:@"Run Didn't Stop" format:@"%@ failed to stop run",[self crateName]];	
	}
}

- (void) sendCommand:(long)aCmd withOptions:(SBC_CmdOptionStruct*)optionBlock expectResponse:(BOOL)askForResponse
{
	SBC_Packet aPacket;
	
	aPacket.cmdHeader.destination			= kSBC_Process;
	aPacket.cmdHeader.cmdID					= aCmd;
	aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_CmdOptionStruct);
	memcpy(aPacket.payload,optionBlock,sizeof(SBC_CmdOptionStruct));
	
	@try {
		[socketLock lock]; //begin critical section
		[self write:socketfd buffer:&aPacket];
		
		if(askForResponse){
			//get the response....
			[self read:socketfd buffer:&aPacket];
			SBC_CmdOptionStruct* optionPtr = (SBC_CmdOptionStruct*)aPacket.payload;
			int i;
			for(i=0;i<kMaxOptions;i++){
				optionBlock->option[i] = optionPtr->option[i];
			}
		}
		[socketLock unlock]; //end critical section
		
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
	
}

- (void) writeLongBlock:(long*) buffer
			  atAddress:(unsigned long) anAddress
			 numToWrite:(unsigned int)  numberLongs
{
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet aPacket;
		aPacket.cmdHeader.destination			= kSBC_Process;
		aPacket.cmdHeader.cmdID					= kSBC_WriteBlock;
		aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_WriteBlockStruct) + numberLongs*sizeof(long);
		
		SBC_WriteBlockStruct* writeBlockPtr = (SBC_WriteBlockStruct*)aPacket.payload;
		writeBlockPtr->address		= anAddress;
		writeBlockPtr->numLongs		= numberLongs;
		writeBlockPtr++;
		memcpy(writeBlockPtr,buffer,numberLongs*sizeof(long));
		
		[self write:socketfd buffer:&aPacket];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}


- (void) readLongBlock:(long*) buffer
			 atAddress:(unsigned long) anAddress
			 numToRead:(unsigned int) numberLongs
{
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet aPacket;
		aPacket.cmdHeader.destination			= kSBC_Process;
		aPacket.cmdHeader.cmdID					= kSBC_ReadBlock;
		aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_ReadBlockStruct);
		
		SBC_ReadBlockStruct* readBlockPtr = (SBC_ReadBlockStruct*)aPacket.payload;
		readBlockPtr->address		= anAddress;
		readBlockPtr->numLongs		= numberLongs;
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:&aPacket]; //write the packet
		[self read:socketfd buffer:&aPacket]; //read the response
		
		SBC_ReadBlockStruct* rp = (SBC_ReadBlockStruct*)aPacket.payload;
		int numLongs = rp->numLongs;
		rp++;
		long* dp = (long*)rp;
		int i;
		for(i=0;i<numLongs;i++){
			buffer[i] = dp[i];
		}
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}

- (void) readByteBlock:(unsigned char *) buffer
			 atAddress:(unsigned int) aVmeAddress
			 numToRead:(unsigned int) numberBytes
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace;
{
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet aPacket;
		aPacket.cmdHeader.destination			= kSBC_Process;
		aPacket.cmdHeader.cmdID					= kSBC_ReadBlock;
		aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_VmeReadBlockStruct);
		
		SBC_VmeReadBlockStruct* readBlockPtr = (SBC_VmeReadBlockStruct*)aPacket.payload;
		readBlockPtr->address			= aVmeAddress;
		readBlockPtr->addressModifier	= anAddressModifier;
		readBlockPtr->addressSpace		= anAddressSpace;
		readBlockPtr->unitSize			= 1;
		readBlockPtr->numItems			= numberBytes;
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:&aPacket]; //write the packet
		[self read:socketfd buffer:&aPacket];  //read the response
		
		SBC_VmeReadBlockStruct* rp = (SBC_VmeReadBlockStruct*)aPacket.payload;
		if(!rp->errorCode){		
			int num = rp->numItems;
			char* dp = (char*)(rp+1);
			memcpy(buffer,dp,num);
		}
		else [self throwError:rp->errorCode address:aVmeAddress];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}

- (void) readWordBlock:(unsigned short *) buffer
			 atAddress:(unsigned int) aVmeAddress
			 numToRead:(unsigned int) numberWords
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace
{
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet aPacket;
		aPacket.cmdHeader.destination			= kSBC_Process;
		aPacket.cmdHeader.cmdID					= kSBC_ReadBlock;
		aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_VmeReadBlockStruct);
		
		SBC_VmeReadBlockStruct* readBlockPtr = (SBC_VmeReadBlockStruct*)aPacket.payload;
		readBlockPtr->address			= aVmeAddress;
		readBlockPtr->addressModifier	= anAddressModifier;
		readBlockPtr->addressSpace		= anAddressSpace;
		readBlockPtr->unitSize			= 2;
		readBlockPtr->numItems			= numberWords;
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:&aPacket]; //write the packet
		[self read:socketfd buffer:&aPacket];  //read the response
		
		SBC_VmeReadBlockStruct* rp = (SBC_VmeReadBlockStruct*)aPacket.payload;
		if(!rp->errorCode){		
			int num = rp->numItems;
			short* dp = (short*)(rp+1);
			memcpy(buffer,dp,num*sizeof(short));
		}
		else [self throwError:rp->errorCode address:aVmeAddress];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}

- (void) readLongBlock:(unsigned long *) buffer
			 atAddress:(unsigned int) aVmeAddress
			 numToRead:(unsigned int) numberLongs
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace
{
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet aPacket;
		aPacket.cmdHeader.destination			= kSBC_Process;
		aPacket.cmdHeader.cmdID					= kSBC_ReadBlock;
		aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_VmeReadBlockStruct);
		
		SBC_VmeReadBlockStruct* readBlockPtr = (SBC_VmeReadBlockStruct*)aPacket.payload;
		readBlockPtr->address			= aVmeAddress;
		readBlockPtr->addressModifier	= anAddressModifier;
		readBlockPtr->addressSpace		= anAddressSpace;
		readBlockPtr->unitSize			= 4;
		readBlockPtr->numItems			= numberLongs;
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:&aPacket];	//write the packet
		[self read:socketfd buffer:&aPacket];		//read the response
		
		SBC_VmeReadBlockStruct* rp = (SBC_VmeReadBlockStruct*)aPacket.payload;
		if(!rp->errorCode){		
			int num = rp->numItems;
			
			rp++;
			memcpy(buffer,rp,num*sizeof(long));
		}
		else [self throwError:rp->errorCode address:aVmeAddress];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}


- (void) writeByteBlock:(unsigned char *) buffer
			  atAddress:(unsigned int) aVmeAddress
			 numToWrite:(unsigned int) numberBytes
			 withAddMod:(unsigned short) anAddressModifier
		  usingAddSpace:(unsigned short) anAddressSpace
{
	@try {
		[socketLock lock]; //begin critical section
		
		SBC_Packet aPacket;
		aPacket.cmdHeader.destination			= kSBC_Process;
		aPacket.cmdHeader.cmdID					= kSBC_WriteBlock;
		aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_VmeWriteBlockStruct) + numberBytes;
		
		SBC_VmeWriteBlockStruct* writeBlockPtr = (SBC_VmeWriteBlockStruct*)aPacket.payload;
		writeBlockPtr->address			= aVmeAddress;
		writeBlockPtr->addressModifier	= anAddressModifier;
		writeBlockPtr->addressSpace		= anAddressSpace;
		writeBlockPtr->unitSize			= 1;
		writeBlockPtr->numItems			= numberBytes;
		char* bPtr = (char*)(writeBlockPtr+1); //point to the payload
		memcpy(bPtr,buffer,numberBytes);
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:&aPacket];	//write the packet
		[self read:socketfd buffer:&aPacket];		//read the response
		
		SBC_VmeReadBlockStruct* rp = (SBC_VmeReadBlockStruct*)aPacket.payload;
		if(rp->errorCode)[self throwError:rp->errorCode address:aVmeAddress];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}


- (void) writeWordBlock:(unsigned short *) buffer
			  atAddress:(unsigned int) aVmeAddress
			 numToWrite:(unsigned int) numberWords
			 withAddMod:(unsigned short) anAddressModifier
		  usingAddSpace:(unsigned short) anAddressSpace
{
	@try {
		[socketLock lock]; //begin critical section
		
		SBC_Packet aPacket;
		aPacket.cmdHeader.destination			= kSBC_Process;
		aPacket.cmdHeader.cmdID					= kSBC_WriteBlock;
		aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_VmeWriteBlockStruct) + numberWords*sizeof(short);
		
		SBC_VmeWriteBlockStruct* writeBlockPtr = (SBC_VmeWriteBlockStruct*)aPacket.payload;
		writeBlockPtr->address			= aVmeAddress;
		writeBlockPtr->addressModifier	= anAddressModifier;
		writeBlockPtr->addressSpace		= anAddressSpace;
		writeBlockPtr->unitSize			= 2;
		writeBlockPtr->numItems			= numberWords;
		short* wPtr = (short*)(writeBlockPtr+1); //point to the payload
		memcpy(wPtr,buffer,numberWords*sizeof(short));
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:&aPacket];	//write the packet
		[self read:socketfd buffer:&aPacket];		//read the response
		
		SBC_VmeReadBlockStruct* rp = (SBC_VmeReadBlockStruct*)aPacket.payload;
		if(rp->errorCode)[self throwError:rp->errorCode address:aVmeAddress];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}

- (void) writeLongBlock:(unsigned long *) buffer
			  atAddress:(unsigned int) aVmeAddress
			 numToWrite:(unsigned int) numberLongs
			 withAddMod:(unsigned short) anAddressModifier
		  usingAddSpace:(unsigned short) anAddressSpace
{
	@try {
		[socketLock lock]; //begin critical section
		
		SBC_Packet aPacket;
		aPacket.cmdHeader.destination			= kSBC_Process;
		aPacket.cmdHeader.cmdID					= kSBC_WriteBlock;
		aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_VmeWriteBlockStruct) + numberLongs*sizeof(long);
		
		SBC_VmeWriteBlockStruct* writeBlockPtr = (SBC_VmeWriteBlockStruct*)aPacket.payload;
		writeBlockPtr->address			= aVmeAddress;
		writeBlockPtr->addressModifier	= anAddressModifier;
		writeBlockPtr->addressSpace		= anAddressSpace;
		writeBlockPtr->unitSize			= 4;
		writeBlockPtr->numItems			= numberLongs;
		writeBlockPtr++;				//point to the payload
		memcpy(writeBlockPtr,buffer,numberLongs*sizeof(long));
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:&aPacket];	//write the packet
		[self read:socketfd buffer:&aPacket];		//read the response
		
		SBC_VmeReadBlockStruct* rp = (SBC_VmeReadBlockStruct*)aPacket.payload;
		if(rp->errorCode)[self throwError:rp->errorCode address:aVmeAddress];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}


//temp discrete ops
- (void) executeCommandList:(ORCommandList*)aList
{
	@try {
		SBC_Packet blockPacket = [aList SBCPacket];
		
		[socketLock lock]; //begin critical section
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:&blockPacket];	//write the packet
		[self read:socketfd buffer:&blockPacket];	//read the response
		[socketLock unlock]; //end critical section
		
		[aList extractData:&blockPacket];
	
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
}


- (void) send:(SBC_Packet*)aSendPacket receive:(SBC_Packet*)aReceivePacket
{
	@try {
		[socketLock lock]; //begin critial section
		[self write:socketfd buffer:aSendPacket];
		[self read:socketfd buffer:aReceivePacket];
		[socketLock unlock]; //end critial section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critial section
		[localException raise];
	}
}



- (void) update
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(update) object:nil];
	if(isRunning){
		[self getRunInfoBlock];
		if(runInfo.readCycles == oldCycleCount){
			if(++missedHeartBeat == 10){
				if(!eCpuDeadAlarm){
					eCpuDeadAlarm = [[ORAlarm alloc] initWithName:@"eCPU appears dead" severity:kHardwareAlarm];
					[eCpuDeadAlarm setSticky:NO];
					[eCpuDeadAlarm setHelpStringFromFile:@"eCPUDeadHelp"];
				}
				if(![eCpuDeadAlarm isPosted]){
					[eCpuDeadAlarm setAcknowledged:NO];
					[eCpuDeadAlarm postAlarm];
				}
			}
		}
		else {
			oldCycleCount = runInfo.readCycles;
		}	
	}
    /*if (throttle > kShrinkThrottleBy && runInfo.amountInBuffer > kAmountInBufferThreshold) {
	 *//* Let's try diminishing the throttle */
	/*throttle -= kShrinkThrottleBy;
	 }*/
	if(isRunning){
		[self performSelector:@selector(update) withObject:nil afterDelay:.5];
	}
}

- (void) runTaskStarted:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
	
	if([[self orcaObjects] count]){
		//set up the irq thread to watch that socket, but only if there are LAMS defined
		stopWatchingIRQ = NO;
		[NSThread detachNewThreadSelector:@selector(watchIrqSocket) toTarget:self withObject:nil];
	}
	
	[eCpuDeadAlarm clearAlarm];
	[eRunFailedAlarm clearAlarm];
	throttleCount = 0;
	missedHeartBeat = 0;
	throttle = 1000;
	[self tellClientToStartRun];
	[self update];
}

-(void) takeData:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
	//this stuff is socket based, so no need to try to ask for data too often. A larger throttleCount
	//will result in larger sized buffers from the SBC.
	if(++throttleCount>throttle){
		throttleCount = 0;
		SBC_Packet aPacket;
        aPacket.cmdHeader.destination	= kSBC_Process;
        aPacket.cmdHeader.cmdID			= kSBC_CBRead;
        aPacket.cmdHeader.numberBytesinPayload = 0;
		[self send:&aPacket receive:&aPacket];
		
		unsigned long* rp = (unsigned long*)aPacket.payload;
		long numLongs = aPacket.cmdHeader.numberBytesinPayload/sizeof(long);
		if(numLongs){
			[aDataPacket addLongsToFrameBuffer:rp length:numLongs];
		}
	}
}

- (void) runIsStopping:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
	@try {
		[self tellClientToStopRun];
		stopWatchingIRQ = YES;
		[self getRunInfoBlock];
		/* We no longer need the throttle since we are just clearing the circular buffer.
		 It will be reset when the run starts.                                           */
		throttle = 0;
		if(runInfo.amountInBuffer > 0){
			lastAmountInBuffer = runInfo.amountInBuffer;
			NSLog(@"%@ %d %d reading out last %d bytes in CB\n",[delegate className],[delegate crateNumber],[delegate slot],runInfo.amountInBuffer);
		}
	}
	@catch (NSException* localException) {
		NSLog(@"%@\n",localException);
	}
}

- (BOOL) doneTakingData
{
	//the remote client has  been told to stop taking data, but there is probably still
	//data in the CB. The run will not actually stop until we return YES from this method.
	[self getRunInfoBlock];
	
	if(lastAmountInBuffer != runInfo.amountInBuffer){
		//as long as the amount in the buffer is changing, we'll ask for more time.
		[[NSNotificationCenter defaultCenter] postNotificationName: ORNeedMoreTimeToStopRun object:self];
		lastAmountInBuffer = runInfo.amountInBuffer;
	}
	
	return (runInfo.amountInBuffer == 0) && !irqThreadRunning;
}

- (void) runTaskStopped:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{	
	[self performSelector:@selector(getRunInfoBlock) withObject:self afterDelay:1];
}


- (void) load_HW_Config:(SBC_crate_config*) aConfig
{	
	SBC_Packet aPacket;
	
	aPacket.cmdHeader.destination			= kSBC_Process;
	aPacket.cmdHeader.cmdID					= kSBC_LoadConfig;
	aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_crate_config);
	memcpy(aPacket.payload,aConfig,sizeof(SBC_crate_config));
	
	[self write:socketfd buffer:&aPacket];	
}

#pragma mark ***DataSource
- (void) getQueMinValue:(unsigned long*)aMinValue maxValue:(unsigned long*)aMaxValue head:(unsigned long*)aHeadValue tail:(unsigned long*)aTailValue
{
	*aMinValue  = 0;
	*aMaxValue  = runInfo.bufferSize;
	*aHeadValue = runInfo.writeIndex;
	*aTailValue = runInfo.readIndex;
	
}

//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------

- (void) connect
{
	if(!socketfd && !irqfd && ([IPNumber length]!=0) && (portNumber!=0)){
		@try {
			//get the socket descriptor for the main com link
			socketfd = [self connectToPort:portNumber];
			
			//send a test word to determine if swapping will be needed. All swapping is handled on the 'other' side.
			long testWord = 0x0000DCBA;
			int bytesWritten = write(socketfd,&testWord,4);
			if(bytesWritten!=4) [NSException raise:@"Test Send Failed" format:@"Couldn't write to %@",IPNumber];
		
			//get the socket descriptor for the interrupt link
			irqfd = [self connectToPort:portNumber+1];
			
			[self setIsConnected: YES];
			[self setTimeConnected:[NSCalendarDate date]];
			[self setReloading:NO];
			
			NSLog(@"Connected to %@ <%@> port: %d\n",[self crateName],IPNumber,portNumber);
			//[self getRunInfoBlock];
			[[delegate crate] performSelector:@selector(connected) withObject:nil afterDelay:1];
			
		}
		@catch (NSException* localException) {
			if(socketfd){
				close(socketfd);
				socketfd = 0;
			}
			if(irqfd){
				close(irqfd);
				irqfd = 0;
			}
			[self setIsConnected: NO];
			[self setTimeConnected:nil];
			
			[localException raise];
		}
		
	}
}

- (void) disconnect
{
	if([self cbTestRunning]){
		exitCBTest = YES;
		[[ORGlobal sharedGlobal] removeRunVeto:@"CBTestInProgress"];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkCBTest object:self];
	}
	if(socketfd){
		close(socketfd);
		socketfd = 0;
	}
	if(irqfd){
		close(irqfd);
		irqfd = 0;
	}
	
	[self setIsConnected: NO];
	[self setTimeConnected:nil];
	NSLog(@"Disconnected from %@ <%@> port: %d\n",[self crateName],IPNumber,portNumber);
	[[delegate crate] disconnected];
	
}

- (int) connectToPort:(unsigned short) aPort
{
	//get the host info
	struct sockaddr_in target_address;					// connector's address information 
	struct hostent* he=gethostbyname([IPNumber cStringUsingEncoding:NSASCIIStringEncoding]);
	if(!he) [NSException raise:@"HostByName Failed" format:@"Couldn't couldn't get hostname for %@",IPNumber];
	
	target_address.sin_family = AF_INET;				// host byte order 
	target_address.sin_port = htons(aPort);				// short, network byte order 
	target_address.sin_addr = *((struct in_addr *)he->h_addr);
	memset(&(target_address.sin_zero), '\0', 8);		// zero the rest of the struct 
	
    int sck = socket(AF_INET, SOCK_STREAM, 0);
	if(sck == kError)[NSException raise:@"Socket Failed" format:@"Couldn't couldn't get a socket for %@ Port %d",IPNumber,aPort];
	
	int oflag = fcntl(sck, F_GETFL);
	fcntl(sck, F_SETFL, oflag | O_NONBLOCK);
	time_t now = time(NULL);
	while (connect(sck, (struct sockaddr *) &target_address, sizeof(target_address)) == -1) {
		if([self canWriteTo:sck]) break;
		if ((time(NULL) - now) > 3){
			[NSException raise:@"Connection Failed" format:@"Couldn't get a connection for %@ Port %d -- Check power and connections.",IPNumber,portNumber];
		}
	}
	//fcntl(sck, F_SETFL, oflag | O_NONBLOCK);
	
	return sck;
}


- (NSString*) crateProcessState
{
	switch(startCrateState){
		case kIdle:				return @"";
		case kTryToConnect:		return @"Trying to connect";
		case kTryToStartCode:	return @"Trying to start";
		case kWaitingForStart:	return @"Waiting for start";
		case kReloadCode:		return @"Reloading/Compiling";
		case kWaitingForReload: return @"Waiting for Reload";
		case kTryToConnect2:	return @"Trying to connect";
		case kDone:				return @"";
		default:				return @"";
	}
}

- (NSString*) crateName
{
	NSString* crateName = [[delegate crate] className];
	if(crateName){
		if([crateName hasPrefix:@"OR"])crateName = [crateName substringFromIndex:2];
		if([crateName hasSuffix:@"Model"])crateName = [crateName substringToIndex:[crateName length]-5];
	}
	else {
		crateName = [[IPNumber copy] autorelease];
	}
	return crateName;
}

- (void) ping
{
	if(!pingTask){
		ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
		pingTask = [[NSTask alloc] init];
		
		[pingTask setLaunchPath:@"/sbin/ping"];
		[pingTask setArguments: [NSArray arrayWithObjects:@"-c",@"5",@"-t",@"10",@"-q",IPNumber,nil]];
		
		[aSequence addTaskObj:pingTask];
		[aSequence setVerbose:YES];
		[aSequence setTextToDelegate:YES];
		[aSequence launch];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkPingTask object:self];
	}
	else {
		[pingTask terminate];
	}
}

- (BOOL) pingTaskRunning
{
	return pingTask != nil;
}

- (void) startCBTransferTest
{
	if([self cbTestRunning]){
		exitCBTest = YES;
		[[ORGlobal sharedGlobal] removeRunVeto:@"CBTestInProgress"];
	}
	else if(![gOrcaGlobals runInProgress]){
		[[ORGlobal sharedGlobal] addRunVeto:@"CBTestInProgress" comment:@"CB Test In Progress"];
		exitCBTest = NO;
		cbTestCount = 0;
		totalRecordsChecked = 0;
		totalErrors = 0;
		startBlockSize = 1000;
		endBlockSize   = 300000;
		productionSpeedValueValid = NO;
		productionSpeed = 0;
		doingProductionTest = NO;
		
		memset(recordSizeHisto,0, 1000*sizeof(int));
		deltaBlockSize = (endBlockSize-startBlockSize)/(numTestPoints-1);
		[self doCBTransferTest];
	}
}
- (int) cbTestCount
{
	return cbTestCount;
}

- (long) totalRecordsChecked
{
	return totalRecordsChecked;
}

- (long) totalErrors
{
	return totalErrors;
}


- (NSPoint) cbPoint:(unsigned)i
{
    if(i<cbTestCount)return cbPoints[i];
    else return NSZeroPoint;
}

- (BOOL) cbTestRunning
{
	return cbTestRunning || !exitCBTest;
}

- (double) cbTestProgress
{
	double val =  100*currentBlockSize/(double)(endBlockSize - startBlockSize + deltaBlockSize);
	return val;
}

- (void) sendPayloadSize:(long)aSize
{
	SBC_CmdOptionStruct optionBlock;
	optionBlock.option[0]	= aSize;
	[self sendCommand:kSBC_PacketOptions withOptions:&optionBlock expectResponse:YES];
}

- (long) payloadSize
{
	return payloadSize;
}

- (void) setPayloadSize:(long)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPayloadSize:payloadSize];
    
	if(aValue<=5000)aValue = 5000;
	else if(aValue>kSBC_MaxPayloadSizeBytes)aValue = kSBC_MaxPayloadSizeBytes;
	
    payloadSize = aValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkNumPayloadSizeChanged object:self];
}


- (int) recordSizeHisto:(int)aChannel
{
	return recordSizeHisto[aChannel];
}

- (int) numHistoChannels
{
	return 1000; //hardcoded all over the place, don't change...
}
- (BOOL) productionSpeedValueValid
{
	return productionSpeedValueValid;
}

- (float) productionSpeed
{
	return productionSpeed;
}


- (void) throwError:(int)anError address:(unsigned long)anAddress
{
	NSString* baseString = [NSString stringWithFormat:@"Address Exception. "];
	NSString* details;
	if(anError == EPERM)		details = @"Operation not permitted";
	else if(anError == ENODEV)	details = @"No such device";
	else if(anError == ENXIO)	details = @"No such device or address";
	else if(anError == EINVAL)	details = @"Invalid argument";
	else if(anError == EFAULT)	details = @"Bad address";
	else if(anError == EBUSY)	details = @"Device Busy";
	else if(anError == ENOMEM)	details = @"Out of Memory";
	else details = [NSString stringWithFormat:@"%d",anError];
	[NSException raise: @"SBC access Error" format:@"%@:%@\nAddress: 0x%08x",baseString,details,anAddress];
}

- (void) fillInScript:(NSString*)theScript
{
	//first, find it in the staging area
	NSString* newScriptPath = [[mainStagingFolder stringByAppendingPathComponent:theScript] stringByExpandingTildeInPath];
	NSMutableString* contents = [NSMutableString stringWithContentsOfFile:newScriptPath encoding:NSASCIIStringEncoding error:nil];
	[contents replaceOccurrencesOfString:@"<serverName>" withString:@"OrcaReadout" options:NSCaseInsensitiveSearch range:NSMakeRange(0, [contents length])];
	[contents replaceOccurrencesOfString:@"<port>" withString:[NSString stringWithFormat:@"%d",portNumber] options:NSCaseInsensitiveSearch range:NSMakeRange(0, [contents length])];

	NSFileManager* fm = [NSFileManager defaultManager];
	if([fm fileExistsAtPath: newScriptPath]) [fm removeItemAtPath:newScriptPath error:nil];
	NSDictionary *attrib = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:0777], NSFilePosixPermissions, NSFileTypeRegular, NSFileType,nil];
	[fm createFileAtPath:newScriptPath contents:[contents dataUsingEncoding:NSASCIIStringEncoding] attributes:attrib]; 
}

- (void) runFailed
{
	[[NSNotificationCenter defaultCenter] postNotificationName:ORRequestRunHalt object:self];
	if(!eRunFailedAlarm){
		eRunFailedAlarm = [[ORAlarm alloc] initWithName:@"Crate failed to start run" severity:kRunInhibitorAlarm];
		[eRunFailedAlarm setSticky:NO];
		//[eRunFailedAlarm setHelpStringFromFile:@"eCPUDeadHelp"];
	}
	if(![eRunFailedAlarm isPosted]){
		[eRunFailedAlarm setAcknowledged:NO];
		[eRunFailedAlarm postAlarm];
	}
}

- (void) startCrateProcess
{
	int oldState = startCrateState;
	switch(startCrateState){
		case kTryToConnect:
			@try {
				NSLog(@"Trying to connect to SBC\n");
				[self connect]; //will throw if can't connect
				startCrateState = kDone;
			}
			@catch (NSException* localException) {
				//couldn't connect, try to start the code
				NSLog(@"Connection to SBC Failed. SBC probably not running.\n");

				startCrateState = kTryToStartCode;
			}
			break;
			
		case kTryToStartCode:
			@try {
				NSLog(@"Staring SBC code\n");
				[self startCrateCode];
				[ORTimer delay:.3];
				startCrateState = kWaitingForStart;
				waitCount = 0;
			}
			@catch (NSException* localException) {
				startCrateState = kReloadCode;
			}
			break;
			
		case kWaitingForStart:
			if(isConnected)startCrateState = kDone;
			else if (goScriptFailed) startCrateState = kDone;
			else {
				@try {
					[self connect];
					startCrateState = kDone;
				}
				@catch (NSException* localException) {
				}
				waitCount++;
				if(waitCount > 200){
					waitCount = 0;
					startCrateState = kReloadCode;
				}
			}
			break;
			
		case kReloadCode:
			[self reloadClient];
			NSLog(@"Waiting for SBC code reload\n");
			startCrateState = kWaitingForReload;
			waitCount = 0;
			break;
			
		case kWaitingForReload:
			if(!reloading){
				startCrateState = kTryToConnect2;
				waitCount = 0;
			}
			else {
				waitCount++;
				if(waitCount > 300){
					waitCount = 0;
					startCrateState = kDone;
					//failed......
					NSLog(@"Failed to reload\n");
					[self setReloading:NO];
				}
			}
			break;
			
		case kTryToConnect2:
			if(isConnected)startCrateState = kDone;
			else {
				@try {
					[self connect];
				}
				@catch (NSException* localException) {
				}
				waitCount++;
				if(waitCount > 10){
					waitCount = 0;
					startCrateState = kDone;
					//failed......
					NSLog(@"Failed to connect after reload\n");
					[self setReloading:NO];
				}
			}
			break;
	} 
	
	if(startCrateState != oldState){
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCrateStartStatusChanged object:self];
	}
	
	
	if(startCrateState!=kDone){
		[self performSelector:@selector(startCrateProcess) withObject:self afterDelay:.1];
	}
	else [self setTryingToStartCrate:NO];
}

- (void) watchIrqSocket
{
	irqThreadRunning = YES;
	SBC_Packet aPacket;
	lamsToAck    = [[ORSafeQueue alloc] init];
	while([self isConnected]){
		if([self dataAvailable:irqfd]){
			[self readSocket:irqfd buffer:&aPacket]; //read the irq
			int irqNumber = aPacket.payload[0];
			int i;
			for(i=0;i<[[self orcaObjects] count]; i++){
				ORSBC_LAMModel* lamObj = [[self orcaObjects] objectAtIndex:i];
				if([lamObj slot] == irqNumber){
					if(![lamObj isBusy]){
						[lamObj processPacket:&aPacket];
						[lamsToAck enqueue:lamObj];
					}
					break;
				}
			}
		}
		
		//ack any lams that have been processed on this side
		int n = [lamsToAck count];
		if(n){
			SBC_LamAckStruct *p = (SBC_LamAckStruct*)aPacket.payload;
			char* lamPtr = (char*)(p+1);
			ORSBC_LAMModel* lamObj = nil;
			do {
				lamObj = [lamsToAck dequeue];
				if(lamObj){
					*lamPtr++ = [lamObj slot];
					p->numToAck++;
				}
			}while(lamObj);
			//send off the ack packet
			[self write:irqfd buffer:&aPacket];
		}
		else if(stopWatchingIRQ) break;
	}
	
	irqThreadRunning = NO;
	[lamsToAck release];
	
	lamsToAck    = nil;
}

- (void) write:(int)aSocket buffer:(SBC_Packet*)aPacket
{
	//Note there are NO locks on this method, but it is private and can only be called from this object. Care must
	//be taken that thread locks are provided at a higher level.
	aPacket->message[0] = '\0';
	if(!aSocket)	[NSException raise:@"Write Error" format:@"SBC Not Connected %@ <%@> port: %d",[self crateName],IPNumber,portNumber];
	
	
	// wait until timeout or data received
    int selectionResult = 0;
    int bytesWritten = 0;
	int numBytesToSend = sizeof(long) +
	sizeof(SBC_CommandHeader) + 
	kSBC_MaxMessageSizeBytes + 
	aPacket->cmdHeader.numberBytesinPayload;
	aPacket->numBytes = numBytesToSend;
	char* packetPtr = (char*)aPacket;		//recast the first 'real' word in the packet
	while (numBytesToSend) {
		// The loop is to ignore EAGAIN and EINTR errors as these are harmless 
		do {
			// set up the file descriptor set
			fd_set write_fds;
			FD_ZERO(&write_fds);
			FD_SET(aSocket, &write_fds);
			
			struct timeval tv;
			tv.tv_sec  = 2;
			tv.tv_usec = 0;
			selectionResult = select(aSocket+1, NULL, &write_fds, NULL, &tv);
		} while (selectionResult == kSelectionError && (errno == EAGAIN || errno == EINTR));
		
        if (selectionResult == kSelectionError){
            [NSException raise:@"Write Error" format:@"Write Error %@ <%@>: %s",[self crateName],IPNumber,strerror(errno)];
        }
        else if (selectionResult == kSelectionTimeout) {
            [NSException raise:@"ConnectionTimeOut" format:@"Write from %@ <%@> port: %d timed out",[self crateName],IPNumber,portNumber];
        }   
		do {
			bytesWritten = write(aSocket,packetPtr,numBytesToSend);
		} while (bytesWritten < 0 && (errno == EAGAIN || errno == EINTR));
		if (bytesWritten > 0) {
			packetPtr += bytesWritten;
			numBytesToSend -= bytesWritten;
			bytesSent += bytesWritten;
		} 
		else if (bytesWritten < 0) {
            if (errno == EPIPE) {
                [self disconnect];
            }
			[NSException raise:@"Write Error" format:@"Write Error(%s) %@ <%@> port: %d",strerror(errno),[self crateName],IPNumber,portNumber];
		}
	}
}

- (void) read:(int)aSocket buffer:(SBC_Packet*)aPacket
{	
	//Note that there are NO locks on this method, but it is private and can only be called from this object. 
	//Care must be taken that thread locks are provided at a higher level in this object
	if(!aSocket)	[NSException raise:@"Read Error" format:@"SBC Not Connected %@ <%@> port: %d",[self crateName],IPNumber,portNumber];
	
	// wait until timeout or data received
	int  selectionResult;
	
	// The loop is to ignore EAGAIN and EINTR errors as these are harmless 
	do {
		// set up the file descriptor set
		fd_set read_fds;
		FD_ZERO(&read_fds);
		FD_SET(aSocket, &read_fds);
		
		struct timeval tv;
		tv.tv_sec  = 2;
		tv.tv_usec = 0;
		selectionResult = select(aSocket+1, &read_fds, NULL, NULL, &tv);
	} while (selectionResult == kSelectionError && (errno == EAGAIN || errno == EINTR));
	
	if(selectionResult > 0){
		[self readSocket:aSocket buffer:aPacket];
	}
	else if (selectionResult == kSelectionError){
		[NSException raise:@"Read Error" format:@"Read Error %@ <%@>: %s",[self crateName], IPNumber,strerror(errno)];
	}
	else if (selectionResult == kSelectionTimeout) {
		[NSException raise:@"ConnectionTimeOut" format:@"Read from %@ <%@> port: %d timed out",[self crateName],IPNumber,portNumber];
	}
	if(aPacket->message[0])NSLog(@"%s\n",aPacket->message);
} 

- (void) readSocket:(int)aSocket buffer:(SBC_Packet*)aPacket
{
	int n;			
    int  selectionResult = 0;
	long numBytesToGet = 0;
	time_t t1 = time(0);
	do {
		n = recv(aSocket, &numBytesToGet, sizeof(numBytesToGet), 0);
		if(n<0 && (errno == EAGAIN || errno == EINTR)){
			int timeout = [self errorTimeOutSeconds];
			if(timeout>0){
				if((time(0)-t1)>timeout) {
					[self disconnect];
					[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
				}
			}
		}
		else break;

	} while (1);
	
	if(n==0){
		[self disconnect];
		[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
	} 
	else if (n<0) {
		[NSException raise:@"Socket Error" format:@"Error: %s",strerror(errno)];
    } 
	else if (n < sizeof(long)) {
        /* We didn't get the whole word.  This probably will never happen. */
        int numToGet = sizeof(numBytesToGet) - n;
        char* ptrToNumBytesToGet = ((char*)&numBytesToGet) + n;
        while (numToGet) {
			// The loop is to ignore EAGAIN and EINTR errors as these are harmless 
			do {
				// set up the file descriptor set
				fd_set read_fds;
				FD_ZERO(&read_fds);
				FD_SET(aSocket, &read_fds);
				
				struct timeval tv;
				tv.tv_sec  = 2;
				tv.tv_usec = 0;
				selectionResult = select(aSocket+1, &read_fds, NULL, NULL, &tv);
			} while (selectionResult == kSelectionError && (errno == EAGAIN || errno == EINTR));

            if(selectionResult > 0){
				time_t t1 = time(0);
				do {
					n = recv(aSocket, ptrToNumBytesToGet, numToGet, 0);	
					if(n<0 && (errno == EAGAIN || errno == EINTR)){
						int timeout = [self errorTimeOutSeconds];
						if(timeout>0){
							if((time(0)-t1)>timeout) {
								[self disconnect];
								[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
							}
						}
					}
					else break;
				} while (1);
				if(n==0){
					[self disconnect];
					[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
				} 
				else if (n<0) {
					[NSException raise:@"Socket Error" format:@"Error <%@>: %s",IPNumber,strerror(errno)];
				} else {
					numToGet -= n;
					ptrToNumBytesToGet += n;    
				}
            }
            else if (selectionResult == kSelectionError){
                [NSException raise:@"Read Error" format:@"Read Error %@ <%@>: %s",[self crateName],IPNumber,strerror(errno)];
            }
            else if (selectionResult == kSelectionTimeout) {
                [NSException raise:@"ConnectionTimeOut" format:@"Read from %@ <%@> port: %d timed out",[self crateName],IPNumber,portNumber];
            }
            
        }
    }
	bytesReceived += sizeof(numBytesToGet);
	numBytesToGet -= sizeof(numBytesToGet);
	
	char* packetPtr = (char*)&aPacket->cmdHeader;
	while(numBytesToGet){
		// The loop is to ignore EAGAIN and EINTR errors as these are harmless 
		do {
			// set up the file descriptor set
			fd_set read_fds;
			FD_ZERO(&read_fds);
			FD_SET(aSocket, &read_fds);
			
			struct timeval tv;
			tv.tv_sec  = 2;
			tv.tv_usec = 0;
			selectionResult = select(aSocket+1, &read_fds, NULL,  NULL, &tv);
		} while (selectionResult == kSelectionError && (errno == EAGAIN || errno == EINTR));
		
        if (selectionResult == kSelectionError){
            [NSException raise:@"Read Error" format:@"Read Error %@ <%@>: %s",[self crateName],IPNumber,strerror(errno)];
        }
        else if (selectionResult == kSelectionTimeout) {
            [NSException raise:@"ConnectionTimeOut" format:@"Read from %@ <%@> port: %d timed out",[self crateName],IPNumber,portNumber];
        }
		time_t t1 = time(0);
		do {
			n = recv(aSocket, packetPtr, numBytesToGet, 0);
			if(n<0 && (errno == EAGAIN || errno == EINTR)){
				int timeout = [self errorTimeOutSeconds];
				if(timeout>0){
					if((time(0)-t1)>timeout) {
						[self disconnect];
						[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
					}
				}
			}
			else break;
			
		} while (1);
		
        if(n==0){
            [self disconnect];
            [NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
        } 
		else if (n<0) {
            [NSException raise:@"Socket Error" format:@"Error <%@>: %s",IPNumber,strerror(errno)];
        } 
		else {
            packetPtr += n;
            numBytesToGet -= n;
            bytesReceived += n;
            missedHeartBeat = 0;
        }
 	}
}

- (BOOL) canWriteTo:(int) sck
{
	fd_set wfds;
	struct timeval tv;
	
	FD_ZERO(&wfds);
	FD_SET(sck, &wfds);
	
	tv.tv_sec = 0;
	tv.tv_usec = 0;
	
	int retval = select(sck + 1, NULL, &wfds, NULL, &tv);
	return (retval > 0) && FD_ISSET(sck, &wfds);
}

- (BOOL) dataAvailable:(int) aSocket
{
	if(!aSocket)return NO;
	
	// set up the file descriptor set
	fd_set fds;
	FD_ZERO(&fds);
	FD_SET(aSocket, &fds);
	
	struct timeval tv;
	tv.tv_sec  = 0;
	tv.tv_usec = 10000;
	
	// wait until timeout or data received
	int  selectionResult = select(aSocket+1, &fds, NULL, NULL, &tv);
	return (selectionResult > 0) && FD_ISSET(aSocket, &fds);
}

- (void) doCBTransferTest
{	
	if(exitCBTest) {
		[[ORGlobal sharedGlobal] removeRunVeto:@"CBTestInProgress"];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkCBTest object:self];
		return;
	}
	if(!cbTestRunning){
		currentBlockSize = startBlockSize + cbTestCount*deltaBlockSize;
		
		if(currentBlockSize <= endBlockSize) [self doOneCBTransferTest:currentBlockSize];
		else if(!productionSpeedValueValid){
			doingProductionTest = YES;
			[self doOneCBTransferTest:payloadSize];
		}
		else {
			exitCBTest = YES;
			[[ORGlobal sharedGlobal] removeRunVeto:@"CBTestInProgress"];
			
			[[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkCBTest object:self];
			return;
		}
	}
	
	[self performSelector:@selector(doCBTransferTest) withObject:nil afterDelay:1];
	
}

- (void) doOneCBTransferTest:(long)aPayloadSize
{
	totalTime = totalPayload = totalMeasurements = 0;
	
	[self sendPayloadSize:aPayloadSize];
	
	SBC_CmdOptionStruct optionBlock;
	[self sendCommand:kSBC_CBTest withOptions:&optionBlock expectResponse:YES];
	
	if(optionBlock.option[0] == 1){
		[self performSelector:@selector(sampleCBTransferSpeed) withObject:nil afterDelay:1];
		cbTestRunning = YES;
		lastInfoUpdate = [[NSDate date] retain];
	}
	
	[[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkCBTest object:self];
}


- (void) sampleCBTransferSpeed
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(sampleCBTransferSpeed) object:nil];
	
	NSDate* now = [NSDate date];
	if([now timeIntervalSinceDate:lastInfoUpdate] > .5){
		[self getRunInfoBlock];
		[lastInfoUpdate release];
		lastInfoUpdate = [now retain];
	}
	
	SBC_Packet aPacket;
	aPacket.cmdHeader.destination	= kSBC_Process;
	aPacket.cmdHeader.cmdID			= kSBC_CBRead;
	aPacket.cmdHeader.numberBytesinPayload = 0;
	
	ORTimer* timer = [[ORTimer alloc] init];
	[timer start];
	[self send:&aPacket receive:&aPacket];
	totalTime += [timer microseconds];
	totalPayload += aPacket.cmdHeader.numberBytesinPayload;
	totalMeasurements++;
	[timer release];
	
	unsigned long* rp = (unsigned long*)aPacket.payload;
	long numLongs = aPacket.cmdHeader.numberBytesinPayload/sizeof(long);
	unsigned long* endPt = rp + numLongs;
	
	
	while(rp<endPt){
		unsigned long n = *rp++;
		long i;
		for(i=1;i<n;i++){
			if(*rp++ != i)totalErrors++;
		}
		totalRecordsChecked++;
		if(n<1000)recordSizeHisto[n]++;
	}
	int sampleSize;
	if(doingProductionTest)sampleSize = 500;
	else sampleSize = 100;
	if(!exitCBTest && runInfo.amountInBuffer > 0 && totalMeasurements < sampleSize){
		[self performSelector:@selector(sampleCBTransferSpeed) withObject:nil afterDelay:0];
	}
	else {
		if(totalMeasurements){
			double aveTime		= totalTime/(double)totalMeasurements;
			double avePayload	= totalPayload/(double)totalMeasurements;
			if(aveTime){
				if(!doingProductionTest){
					cbPoints[cbTestCount].x = currentBlockSize/1000.;
					cbPoints[cbTestCount].y = avePayload/aveTime;
					cbTestCount++;
				}
				else {
					productionSpeedValueValid = YES;
					productionSpeed = avePayload/aveTime;
					NSLog(@"Run-Time socket throughput estimated to be: %.1f MB/sec with payload size of %d KB \n",productionSpeed,payloadSize/1000);
				}
			}
		}
		cbTestRunning = NO;
		[[NSNotificationCenter defaultCenter] postNotificationName:ORSBC_LinkCBTest object:self];
	}
}

- (void) monitorJobFor:(id)aDelegate statusSelector:(SEL)aSelector
{
	jobDelegate = aDelegate;
	statusSelector= aSelector;
	[self monitorJob];
}

- (void) monitorJob
{
	SBC_Packet aPacket;
	aPacket.cmdHeader.destination			= kSBC_Process;
	aPacket.cmdHeader.cmdID					= kSBC_JobStatus;
	aPacket.cmdHeader.numberBytesinPayload	= sizeof(SBC_JobStatusStruct);
	
	@try {
		[self send:&aPacket receive:&aPacket];
		
		SBC_JobStatusStruct* p	= (SBC_JobStatusStruct*)aPacket.payload;
		if([jobDelegate respondsToSelector:statusSelector]){
			ORSBCLinkJobStatus* aJobStatus = [ORSBCLinkJobStatus jobStatus:p message:aPacket.message];
			[self setJobStatus:aJobStatus];
			//NSLog(@"monitor job ok: job %s running with message: %s\n", [aJobStatus running]?"is":"is not", [aJobStatus message]);
			[jobDelegate performSelector:statusSelector withObject:jobStatus];
		}
		if(p->running){
			[self performSelector:@selector(monitorJob) withObject:nil afterDelay:0.1];
		}
	}
	@catch(NSException* localException) {
	}
}
@end

//a quicky wrapper so we can pass the job status around as an object.
@implementation ORSBCLinkJobStatus
+ (id) jobStatus:(SBC_JobStatusStruct*) p message:(char*)aPacketMessage
{
	return [[[ORSBCLinkJobStatus alloc] initWith:p message:aPacketMessage] autorelease];
}
- (id) initWith:(SBC_JobStatusStruct*)p message:(char*)aPacketMessage
{
	self = [super init];
	memcpy(&status,p,sizeof(SBC_JobStatusStruct));
	message = [[NSString stringWithCString:aPacketMessage encoding:NSASCIIStringEncoding] retain];
	return self;
}
- (void) dealloc
{
	[message release];
	[super dealloc];
}
- (NSString*) message {return message;}
- (long) running	 { return status.running; }
- (long) finalStatus { return status.finalStatus; }
- (long) progress	 { return status.progress; }





@end