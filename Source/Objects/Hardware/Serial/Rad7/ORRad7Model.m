//--------------------------------------------------------
// ORRad7Model
// Created by Mark  A. Howe on Fri Jul 22 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORRad7Model.h"
#import "ORSerialPort.h"
#import "ORSerialPortList.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"

#pragma mark ***External Strings
NSString* ORRad7ModelMaxRadonChanged	= @"ORRad7ModelMaxRadonChanged";
NSString* ORRad7ModelAlarmLimitChanged	= @"ORRad7ModelAlarmLimitChanged";
NSString* ORRad7ModelMakeFileChanged	= @"ORRad7ModelMakeFileChanged";
NSString* ORRad7ModelVerboseChanged		= @"ORRad7ModelVerboseChanged";
NSString* ORRad7ModelDeleteDataOnStartChanged = @"ORRad7ModelDeleteDataOnStartChanged";
NSString* ORRad7ModelRunToPrintChanged	= @"ORRad7ModelRunToPrintChanged";
NSString* ORRad7ModelDataPointArrayChanged = @"ORRad7ModelDataPointArrayChanged";
NSString* ORRad7ModelRunStateChanged	= @"ORRad7ModelRunStateChanged";
NSString* ORRad7ModelOperationStateChanged = @"ORRad7ModelOperationStateChanged";
NSString* ORRad7ModelTUnitsChanged		= @"ORRad7ModelTUnitsChanged";
NSString* ORRad7ModelRUnitsChanged		= @"ORRad7ModelRUnitsChanged";
NSString* ORRad7ModelFormatChanged		= @"ORRad7ModelFormatChanged";
NSString* ORRad7ModelToneChanged		= @"ORRad7ModelToneChanged";
NSString* ORRad7ModelPumpModeChanged	= @"ORRad7ModelPumpModeChanged";
NSString* ORRad7ModelThoronChanged		= @"ORRad7ModelThoronChanged";
NSString* ORRad7ModelModeChanged		= @"ORRad7ModelModeChanged";
NSString* ORRad7ModelRecycleChanged		= @"ORRad7ModelRecycleChanged";
NSString* ORRad7ModelCycleTimeChanged	= @"ORRad7ModelCycleTimeChanged";
NSString* ORRad7ModelProtocolChanged	= @"ORRad7ModelProtocolChanged";
NSString* ORRad7ModelPollTimeChanged	= @"ORRad7ModelPollTimeChanged";
NSString* ORRad7ModelSerialPortChanged	= @"ORRad7ModelSerialPortChanged";
NSString* ORRad7ModelPortNameChanged	= @"ORRad7ModelPortNameChanged";
NSString* ORRad7ModelPortStateChanged	= @"ORRad7ModelPortStateChanged";
NSString* ORRad7ModelStatusChanged		= @"ORRad7ModelStatusChanged";
NSString* ORRad7ModelUpdatePlot			= @"ORRad7ModelUpdatePlot";

NSString* ORRad7Lock = @"ORRad7Lock";

@interface ORRad7Model (private)
- (void) timeout;
- (void) processOneCommandFromQueue;
- (void) process_response:(NSString*)theResponse;
- (void) goToNextCommand;
- (void) handleSetupReview:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleStatusInfo:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleSetupParam:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleDataFree:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleDataCom:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleDataRecord:(NSString*)aLine;
- (void) handleTestCom:(NSString*)aLine lineNumber:(int) lineNumber;
- (NSNumber*) getNumber:(NSString*)aString separator:(NSString*)aSeparator numberIndex:(int)anIndex;
- (NSNumber*) getNumber:(NSString*)aString separator:(NSString*)aSeparator;
- (void) startTimeOut;
- (double) convertTime:(NSArray*)parts;
- (void) resetDataSet;
- (void) clearTempVerbose;
@end

@implementation ORRad7Model

enum {
	kRad7PowerUp,
	kSpecialStatus,
	kSpecialStart,
	kSpecialStop,
	kSetupReview,
	kSetupMode,
	kSetupPump,
	kSetupThoron,
	kSetupTone,
	kSetupFormat,
	kSetupUnits,
	kSetupProtocol,
	kSetupRecycle,
	kSetupCycle,
	kSetupSave,
	kDataFree,
	kDataErase,
	kDataCom,
	kTestCom,
	kDumpValues,
	kNumberRad7Cmds //must be last
};
#define kRad7CmdTimeout  10
#define kRad7CommErr  -999

static struct {
	NSString* commandName;
	unsigned int cmdId;
	float        waitTime;
	unsigned int expectedReturnLines;
} rad7Cmds[kNumberRad7Cmds] = {
	{@"PowerUpSequence", kRad7PowerUp,	 5,		17},
	{@"SPECIAL STATUS",  kSpecialStatus, 0.5,	6},
	{@"SPECIAL START",   kSpecialStart,  0.5,	3},
	{@"SPECIAL STOP",    kSpecialStop,   0.5,	3},
	{@"SETUP REVIEW",    kSetupReview,	 2,		13},
	{@"SETUP MODE",      kSetupMode,	 .5,	3},
	{@"SETUP PUMP",      kSetupPump,	 .5,	3},
	{@"SETUP THORON",    kSetupThoron,   .5,	3},
	{@"SETUP TONE",      kSetupTone,	 .5,	3},
	{@"SETUP FORMAT",    kSetupFormat,	 .5,	3},
	{@"SETUP UNITS",     kSetupUnits,	 .5,	3},
	{@"SETUP PROTOCOL",  kSetupProtocol, .5,	3},
	{@"SETUP RECYCLE",   kSetupRecycle,  .5,	3},
	{@"SETUP CYCLE",     kSetupCycle,	 .5,	4},
	{@"SETUP SAVUSER",   kSetupSave,	 .5,	3},
	{@"DATA FREE",		 kDataFree,		 .5,	3},
	{@"DATA ERASE",		 kDataErase,	 .5,	3},
	{@"DATA COM",		 kDataCom,		 10,	3}, //prints whole run
	{@"TEST COM",		 kTestCom,		  3,	2}, //prints current cycle
	{@"++DumpUser",      kDumpValues,	  3,	13},
};

#define kNumberRad7FormatNames 4
static NSString* rad7FormatNames[kNumberRad7FormatNames] = {
	@"OFF   ",
	@"SHORT ",
	@"MEDIUM",
	@"LONG  "
};

#define kNumberRad7ToneNames 3
static NSString* rad7ToneNames[kNumberRad7ToneNames] = {
	@"OFF   ",
	@"CHIME ",
	@"GEIGER"
};

#define kNumberRad7ModeNames 5
static NSString* rad7ModeNames[kNumberRad7ModeNames] = {
	@"SNIFF ",
	@"AUTO  ",
	@"WAT-40",
	@"WAT250",
	@"NORMAL"
};

#define kNumberRad7PumpModeNames 4
static NSString* rad7PumpModeNames[kNumberRad7PumpModeNames] = {
	@"AUTO",
	@"ON  ",
	@"OFF ",
	@"GRAB"
};

#define kNumberRad7ProtocolNames 10
static NSString* rad7ProtocolNames[kNumberRad7ProtocolNames] = {
	@"NONE  ",
	@"SNIFF ",
	@"1-DAY ",
	@"2-DAY ",
	@"WEEKS ",
	@"USER  ",
	@"GRAB  ",
	@"WAT-40",
	@"WAT250",
	@"THORON"
};

#define kNumberRad7ThoronNames 2
static NSString* rad7ThoronNames[kNumberRad7ThoronNames] = {
	@"ON ",
	@"OFF"
};
- (id) init
{
	self = [super init];
    [self registerNotificationObservers];
	return self;
}

- (void) dealloc
{
    [dataPointArray release];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [buffer release];
	[cmdQueue release];
	[lastRequest release];
    [portName release];
	[stopRunFilePath release];
    if([serialPort isOpen]){
        [serialPort close];
    }
    [serialPort release];
	[statusDictionary release];
	
	[super dealloc];
}

- (void) sleep
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[super sleep];
}

- (void) wakeUp
{
	[super wakeUp];
	if(pollTime){
		[self pollHardware];
	}
	//temp for testing
	if(!dataPointArray){
		int i;
		for(i=0;i<100;i++){
			if(!dataPointArray){
				[self setDataPointArray:[NSMutableArray array]];
			}
			ORRad7DataPt* aPt = [[[ORRad7DataPt alloc] init] autorelease];
			NSDate *date = [NSDate date];  
			NSTimeInterval t1 = [date timeIntervalSince1970]+i;
			
			[aPt setTime:t1];
			[aPt setValue:random_range(30,100)];
			[aPt setRh:   random_range(10,30)];
			[dataPointArray addObject:aPt];
			[[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelUpdatePlot 
																object:self];
		}
	}
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"Rad7.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORRad7Controller"];
}

- (void) registerNotificationObservers
{
	NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];

    [notifyCenter addObserver : self
                     selector : @selector(dataReceived:)
                         name : ORSerialPortDataReceived
                       object : nil];
}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		
        NSString* theString = [[[[NSString alloc] initWithData:[[note userInfo] objectForKey:@"data"] 
												      encoding:NSASCIIStringEncoding] autorelease] uppercaseString];
		
		//the serial port may break the data up into small chunks, so we have to accumulate the chunks until
		//we get a full piece.
		theString = [[theString componentsSeparatedByString:@"\n"] componentsJoinedByString:@""];
		theString = [[theString componentsSeparatedByString:@">"] componentsJoinedByString:@""];
		
        if(!buffer)buffer = [[NSMutableString string] retain];
        [buffer appendString:theString];	
		
        do {
            NSRange lineRange = [buffer rangeOfString:@"\r"];
            if(lineRange.location!= NSNotFound){
                NSString* theResponse = [[[buffer substringToIndex:lineRange.location+1] copy] autorelease];
                [buffer deleteCharactersInRange:NSMakeRange(0,lineRange.location+1)];      //take the cmd out of the buffer
				theResponse = [theResponse stringByReplacingOccurrencesOfString:@"\r" withString:@""];
				theResponse = [theResponse stringByReplacingOccurrencesOfString:@"\n" withString:@""];

				if([theResponse length] != 0){
					[self process_response:theResponse];
				}
            }
        } while([buffer rangeOfString:@"\r"].location!= NSNotFound);
	}
}

#pragma mark ***Accessors

- (unsigned long) maxRadon
{
    return maxRadon;
}

- (void) setMaxRadon:(unsigned long)aMaxRadon
{
    [[[self undoManager] prepareWithInvocationTarget:self] setMaxRadon:maxRadon];
    
    maxRadon = aMaxRadon;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelMaxRadonChanged object:self];
}

- (unsigned long) alarmLimit
{
    return alarmLimit;
}

- (void) setAlarmLimit:(unsigned long)aAlarmLimit
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAlarmLimit:alarmLimit];
    
    alarmLimit = aAlarmLimit;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelAlarmLimitChanged object:self];
}
- (BOOL) makeFile
{
    return makeFile;
}

- (void) setMakeFile:(BOOL)aMakeFile
{
    [[[self undoManager] prepareWithInvocationTarget:self] setMakeFile:makeFile];
    makeFile = aMakeFile;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelMakeFileChanged object:self];
}

- (BOOL) verbose
{
    return verbose;
}

- (void) setVerbose:(BOOL)aVerbose
{
    [[[self undoManager] prepareWithInvocationTarget:self] setVerbose:verbose];
    verbose = aVerbose;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelVerboseChanged object:self];
}

- (BOOL) deleteDataOnStart
{
    return deleteDataOnStart;
}

- (void) setDeleteDataOnStart:(BOOL)aDeleteDataOnStart
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDeleteDataOnStart:deleteDataOnStart];
    deleteDataOnStart = aDeleteDataOnStart;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelDeleteDataOnStartChanged object:self];
}

- (int) runToPrint
{
    return runToPrint;
}

- (void) setRunToPrint:(int)aRunToPrint
{
	if(aRunToPrint<1)aRunToPrint = 1;
	else if(aRunToPrint>99)aRunToPrint = 99;
    [[[self undoManager] prepareWithInvocationTarget:self] setRunToPrint:runToPrint];
    runToPrint = aRunToPrint;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRunToPrintChanged object:self];
}

- (NSMutableArray*) dataPointArray
{
    return dataPointArray;
}

- (void) setDataPointArray:(NSMutableArray*)anArray
{
    [anArray retain];
    [dataPointArray release];
    dataPointArray = anArray;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelDataPointArrayChanged object:self];
}

- (int) runState
{
    return runState;
}

- (void) setRunState:(int)aRunState
{
    runState = aRunState;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRunStateChanged object:self];
}

- (int) operationState
{
    return operationState;
}

- (void) setOperationState:(int)aOperationState
{
    operationState = aOperationState;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelOperationStateChanged object:self];
}

- (NSString*) operationStateString
{
	switch(operationState){
		case kRad7Idle:				return @"Idle";
		case kRad7UpdatingSettings: return @"Updating Settings";
		case kRad7DumpingSettings:  return @"Dumping Settings";
		case kRad7Initializing:		return @"Initialing HW";
		case kRad7ExecutingGroup:	return @"Executing Cmd Group";
		default: return @"Idle";
	}
}

- (int) tUnits
{
    return tUnits;
}

- (void) setTUnits:(int)aUnits
{
    [[[self undoManager] prepareWithInvocationTarget:self] setTUnits:tUnits];
    tUnits = aUnits;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelTUnitsChanged object:self];
}

- (int) rUnits
{
    return rUnits;
}

- (void) setRUnits:(int)aUnits
{
    [[[self undoManager] prepareWithInvocationTarget:self] setRUnits:rUnits];
    rUnits = aUnits;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRUnitsChanged object:self];
}

- (int) formatSetting
{
    return formatSetting;
}

- (void) setFormatSetting:(int)aFormat
{
    [[[self undoManager] prepareWithInvocationTarget:self] setFormatSetting:formatSetting];
    formatSetting = aFormat;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelFormatChanged object:self];
}

- (int) tone
{
    return tone;
}

- (void) setTone:(int)aTone
{
    [[[self undoManager] prepareWithInvocationTarget:self] setTone:tone];
    tone = aTone;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelToneChanged object:self];
}

- (int) pumpMode
{
    return pumpMode;
}

- (void) setPumpMode:(int)aPumpMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPumpMode:pumpMode];
    pumpMode = aPumpMode;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPumpModeChanged object:self];
}

- (void) convertUnitsString:(NSString*)aUnitsString
{
	//should be in format like "PCI/L  `C"
	aUnitsString = [aUnitsString stringByReplacingOccurrencesOfString:@"`" withString:@""];
	aUnitsString = [aUnitsString removeExtraSpaces];

	NSArray* parts = [aUnitsString componentsSeparatedByString:@" "];
	if([parts count]==2){
		NSString* rU = [parts objectAtIndex:0];
		NSString* tU = [parts objectAtIndex:1];
		
		if([rU isEqualToString:@"PCI/L"])		[self setRUnits:kRad7PciL];
		else if([rU isEqualToString:@"BQ/M3"])	[self setRUnits:kRad7bqm3];
		else if([rU isEqualToString:@"CPM"])    [self setRUnits:kRad7cpm];
		else									[self setRUnits:kRad7ncnts];

		if([tU isEqualToString:@"C"])	[self setTUnits:kRad7Centigrade];
		else							[self setTUnits:kRad7Fahrenheit];
		
	}
}

- (int) convertFormatStringToIndex:(NSString*)aMode
{
	aMode = [aMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7FormatNames;i++){
		if([aMode isEqualToString:rad7FormatNames[i]])return i;
	}
	return 0;
}


- (int) convertToneStringToIndex:(NSString*)aMode
{
	aMode = [aMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7ToneNames;i++){
		if([aMode isEqualToString:[rad7ToneNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
}

- (int) convertModeStringToIndex:(NSString*)aMode
{
	aMode = [aMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7ModeNames;i++){
		if([aMode isEqualToString:[rad7ModeNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
}

- (int) convertPumpModeStringToIndex:(NSString*)aPumpMode
{
	aPumpMode = [aPumpMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7PumpModeNames;i++){
		if([aPumpMode isEqualToString:[rad7PumpModeNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
}

- (int) convertProtocolStringToIndex:(NSString*)aProtocol
{
	aProtocol = [aProtocol trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7ProtocolNames;i++){
		if([aProtocol isEqualToString:[rad7ProtocolNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
	
}

- (int) convertThoronStringToIndex:(NSString*)aMode
{
	aMode = [aMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7ThoronNames;i++){
		if([aMode isEqualToString:[rad7ThoronNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
}

- (int) convertCycleHours:(NSString*)hourString minutes:(NSString*)minutesString
{
	return [hourString intValue]*60 + [minutesString intValue];
}

- (BOOL) thoron
{
    return thoron;
}

- (void) setThoron:(BOOL)aThoron
{
    [[[self undoManager] prepareWithInvocationTarget:self] setThoron:thoron];
    
    thoron = aThoron;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelThoronChanged object:self];
}

- (int) mode
{
    return mode;
}

- (void) setMode:(int)aMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setMode:mode];
    
    mode = aMode;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelModeChanged object:self];
}

- (int) recycle
{
    return recycle;
}

- (void) setRecycle:(int)aRecycle
{
	if(aRecycle < 0) aRecycle = 0;
	if(aRecycle > 99)aRecycle = 99;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setRecycle:recycle];
    
    recycle = aRecycle;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRecycleChanged object:self];
}

- (int) cycleTime
{
    return cycleTime;
}

- (void) setCycleTime:(int)aCycleTime
{
	if(aCycleTime<0)aCycleTime=1;
	else if(aCycleTime> 24*60)aCycleTime=24*60;
    [[[self undoManager] prepareWithInvocationTarget:self] setCycleTime:cycleTime];
    
    cycleTime = aCycleTime;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelCycleTimeChanged object:self];
}

- (int) protocol
{
    return protocol;
}

- (void) setProtocol:(int)aProtocol
{
    [[[self undoManager] prepareWithInvocationTarget:self] setProtocol:protocol];
    protocol = aProtocol;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelProtocolChanged object:self];
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPollTimeChanged object:self];

	if(pollTime){
		[self performSelector:@selector(pollHardware) withObject:nil afterDelay:2];
	}
	else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	}
}




- (unsigned long) timeMeasured
{
	return timeMeasured;
}

- (NSString*) lastRequest
{
	return lastRequest;
}

- (void) setLastRequest:(NSString*)aRequest
{
	if(aRequest){
		int i;
		for(i=0;i<kNumberRad7Cmds;i++){
			if([aRequest hasPrefix:rad7Cmds[i].commandName]){
				
				currentRequest = rad7Cmds[i].cmdId;
				waitTime       = rad7Cmds[i].waitTime;
				expectedCount  = rad7Cmds[i].expectedReturnLines;
				
				requestCount = 0;
				[lastRequest autorelease];
				lastRequest  = [aRequest copy];  
			}
			else if([aRequest hasPrefix:@"++"]){
				waitTime       = 0;
				expectedCount  = 0;

			}
		}
	}
	else {
		[lastRequest autorelease];
		lastRequest  = [aRequest copy];  
	}
}

- (BOOL) portWasOpen
{
    return portWasOpen;
}

- (void) setPortWasOpen:(BOOL)aPortWasOpen
{
    portWasOpen = aPortWasOpen;
}

- (NSString*) portName
{
    return portName;
}

- (void) setPortName:(NSString*)aPortName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];    

        BOOL valid = NO;
        NSEnumerator *enumerator = [ORSerialPortList portEnumerator];
        ORSerialPort *aPort;
        while (aPort = [enumerator nextObject]) {
            if([portName isEqualToString:[aPort name]]){
                [self setSerialPort:aPort];
                if(portWasOpen){
                    [self openPort:YES];
				}
                valid = YES;
                break;
            }
        } 
        if(!valid){
            [self setSerialPort:nil];
        }       
    }

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPortNameChanged object:self];
}

- (ORSerialPort*) serialPort
{
    return serialPort;
}

- (void) setSerialPort:(ORSerialPort*)aSerialPort
{
    [aSerialPort retain];
    [serialPort release];
    serialPort = aSerialPort;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelSerialPortChanged object:self];
}

- (void) openPort:(BOOL)state
{
    if(state) {
		[serialPort setSpeed:9600];
		[serialPort setParityNone];
		[serialPort setStopBits2:NO];
		[serialPort setDataBits:8];
        [serialPort open];
    }
    else [serialPort close];
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPortStateChanged object:self];
}

- (NSDictionary*) statusDictionary
{
	return statusDictionary;
}

#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setMaxRadon:			[decoder decodeInt32ForKey:@"maxRadon"]];
	[self setAlarmLimit:		[decoder decodeInt32ForKey:@"alarmLimit"]];
	[self setMakeFile:			[decoder decodeBoolForKey:	@"makeFile"]];
	[self setVerbose:			[decoder decodeBoolForKey:	@"verbose"]];
	[self setDeleteDataOnStart:	[decoder decodeBoolForKey:	@"deleteDataOnStart"]];
	[self setRunToPrint:		[decoder decodeIntForKey:	@"runToPrint"]];
	[self setTUnits:			[decoder decodeIntForKey:	@"tUnits"]];
	[self setRUnits:			[decoder decodeIntForKey:	@"rUnits"]];
	[self setFormatSetting:		[decoder decodeIntForKey:	@"formatSetting"]];
	[self setTone:				[decoder decodeIntForKey:	@"tone"]];
	[self setPumpMode:			[decoder decodeIntForKey:	@"pumpMode"]];
	[self setThoron:			[decoder decodeBoolForKey:	@"thoron"]];
	[self setMode:				[decoder decodeIntForKey:	@"mode"]];
	[self setRecycle:			[decoder decodeIntForKey:	@"recycle"]];
	[self setCycleTime:			[decoder decodeIntForKey:	@"cycleTime"]];
	[self setProtocol:			[decoder decodeIntForKey:	@"protocol"]];
	[self setPollTime:			[decoder decodeIntForKey:	@"ORRad7ModelPollTime"]];
	[self setPortWasOpen:		[decoder decodeBoolForKey:	@"ORRad7ModelPortWasOpen"]];
    [self setPortName:			[decoder decodeObjectForKey:@"portName"]];
	[[self undoManager] enableUndoRegistration];
	
    [self registerNotificationObservers];

	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeInt32:	maxRadon		forKey:@"maxRadon"];
    [encoder encodeInt32:	alarmLimit		forKey:@"alarmLimit"];
    [encoder encodeBool:	makeFile		forKey:@"makeFile"];
    [encoder encodeBool:	verbose			forKey:@"verbose"];
    [encoder encodeBool:	deleteDataOnStart forKey:@"deleteDataOnStart"];
    [encoder encodeInt:		runToPrint		forKey:@"runToPrint"];
    [encoder encodeInt:		rUnits			forKey: @"rUnits"];
    [encoder encodeInt:		tUnits			forKey: @"tUnits"];
    [encoder encodeInt:		formatSetting	forKey: @"formatSetting"];
    [encoder encodeInt:		tone			forKey: @"tone"];
    [encoder encodeInt:		pumpMode		forKey: @"pumpMode"];
    [encoder encodeBool:    thoron			forKey: @"thoron"];
    [encoder encodeInt:     mode			forKey: @"mode"];
    [encoder encodeInt:     recycle			forKey: @"recycle"];
    [encoder encodeInt:     cycleTime		forKey: @"cycleTime"];
    [encoder encodeInt:		protocol		forKey: @"protocol"];
    [encoder encodeInt:		pollTime		forKey:	@"ORRad7ModelPollTime"];
    [encoder encodeBool:	portWasOpen		forKey:	@"ORRad7ModelPortWasOpen"];
    [encoder encodeObject:	portName		forKey: @"portName"];
}

#pragma mark *** Commands
- (void) addCmdToQueue:(NSString*)aCmd
{
    if([serialPort isOpen]){ 
		if(!cmdQueue)cmdQueue = [[NSMutableArray array] retain];
		[cmdQueue addObject:aCmd];
		if(!lastRequest){
			[self processOneCommandFromQueue];
		}
	}
}

- (void) specialStart
{
	NSLog(@"Starting Rad7\n");
	[self setRunState:kRad7RunStateUnKnown];
	if(deleteDataOnStart)	{
		[self resetDataSet];
		[self addCmdToQueue:@"DATA ERASE YES"];
	}
	[self initHardware];
	[self addCmdToQueue:@"++StartGroup"];
	[self addCmdToQueue:@"SPECIAL STATUS"];
	[self addCmdToQueue:@"SPECIAL START"];
	[self addCmdToQueue:@"SPECIAL STATUS"];
	[self addCmdToQueue:@"++EndGroup"];
}

- (void) specialStop
{
	NSLog(@"Stopping Rad7\n");
	[self setRunState:kRad7RunStateUnKnown];
	[self addCmdToQueue:@"++StartGroup"];
	[self addCmdToQueue:@"SPECIAL STATUS"];
	[self addCmdToQueue:@"SPECIAL STOP"];
	[self addCmdToQueue:@"SPECIAL STATUS"];
	[self addCmdToQueue:@"++EndGroup"];
}

- (void) specialStatus
{
	[self addCmdToQueue:@"++StartGroup"];
	[self addCmdToQueue:@"SPECIAL STATUS"];
	[self addCmdToQueue:@"DATA FREE"];
	[self addCmdToQueue:@"++EndGroup"];
}

- (void) dataErase
{
	[self addCmdToQueue:@"DATA ERASE YES"];
}

- (void) dataDelete:(int) runNumber
{
	if(runNumber>0 && runNumber < 99){
		[self addCmdToQueue:[NSString stringWithFormat: @"DATA DELETE %02d",runNumber]];
		[self addCmdToQueue:@"YES"];
		[self addCmdToQueue:@"DATA RENUMBER"];
	}
	else NSLog(@"Rad7: runNumber for dataDelete must be between 0 and 99 inclusive\n");
}

- (void) printDataInProgress
{
	[self addCmdToQueue:@"TEST COM"];	
}

- (void) printRun
{
	tempVerbose = YES;
	[self printRun:runToPrint];
}

- (void) printRun:(int) runNumber
{
	if(runNumber>0 && runNumber < 99){
		[self addCmdToQueue:[NSString stringWithFormat: @"DATA COM %02d",runNumber]];
	}
	else NSLog(@"Rad7: runNumber for dataCom must be between 0 and 99 inclusive\n");
}

- (void) setupCycle
{
	int hours = cycleTime/60;
	int minutes = cycleTime - hours*60;
	NSString* cycleString = [NSString stringWithFormat:@"%02d:%02d",hours,minutes];
	[self addCmdToQueue:[NSString stringWithFormat: @"SETUP CYCLE %@",cycleString]];
}

- (void) setupUnits
{
	NSString* unitString = @"";
	switch (rUnits){
		case 0: unitString = [unitString stringByAppendingString: @"PCI/L"]; break;
		case 1: unitString = [unitString stringByAppendingString: @"BQ/M3"]; break;
		case 2: unitString = [unitString stringByAppendingString: @"CPM  "]; break;
		default: unitString = [unitString stringByAppendingString:@"#CNTS"]; break;
	}
	unitString = [unitString stringByAppendingString:@" "];
	switch (tUnits){
		case 0: unitString = [unitString stringByAppendingString: @"C"]; break;
		default: unitString = [unitString stringByAppendingString:@"F"]; break;
	}
	
	[self addCmdToQueue:[NSString stringWithFormat: @"SETUP UNITS %@",unitString]];
}

- (void) saveUser
{
	[self addCmdToQueue:[NSString stringWithFormat: @"SETUP SAVUSER YES"]];
}

- (void) setupRecycle
{
	[self addCmdToQueue:[NSString stringWithFormat: @"SETUP RECYCLE %d",recycle]];
}

- (void) setupMode
{
	if(mode >= 0 && mode <kNumberRad7ModeNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP MODE %@",rad7ModeNames[mode]]];
	}
}
- (void) setupProtocol
{
	if(protocol >= 0 && protocol <kNumberRad7ProtocolNames){
		NSString* paramString;
		if(protocol == 0) paramString = @"(NONE)";
		else paramString = rad7ProtocolNames[protocol];
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP PROTOCOL %@",paramString]];
	}
}
- (void) setupThoron
{
	if(thoron >= 0 && thoron <kNumberRad7ThoronNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP THORON %@",rad7ThoronNames[thoron]]];
	}
}
- (void) setupPumpMode
{
	if(pumpMode >= 0 && pumpMode <kNumberRad7PumpModeNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP PUMP %@",rad7PumpModeNames[pumpMode]]];
	}
}

- (void) setupTone
{
	if(tone >= 0 && tone <kNumberRad7ToneNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP TONE %@",rad7ToneNames[tone]]];
	}
}

- (void) setupFormat
{
	if(formatSetting >= 0 && formatSetting <kNumberRad7FormatNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP FORMAT %@",rad7FormatNames[formatSetting]]];
	}
}

- (void) loadDialogFromHardware
{
	if(operationState == kRad7Idle){
		[self addCmdToQueue:@"SETUP REVIEW"];
		[self addCmdToQueue:@"++HWReviewDone"];
		[self setOperationState:kRad7UpdatingSettings];
		NSLog(@"Getting settings from Rad7.... Takes a long time... Be Patient.\n");
	}
	else NSLog(@"Can not load Rad7 Dialog from HW -- some other operation is in progress\n");
}

- (void) dumpUserValues
{
	[self addCmdToQueue:@"++DumpUser"];
	[self setOperationState:kRad7DumpingSettings];
	[self addCmdToQueue:@"++HWReviewDone"];
	NSLog(@"Getting settings from Rad7.... Takes a long time... Be Patient.\n");
}

- (void) initHardware
{
	[self addCmdToQueue:@"++StartHWInit"];
	[self setupProtocol];
	if(protocol == kRad7ProtocolNone){
		[self setupMode];
		[self setupPumpMode];
		[self setupThoron];
		[self setupRecycle];
		[self setupCycle];
	}
	[self setupTone];
	[self setupFormat];
	[self setupUnits];
	
	[self addCmdToQueue:@"++HWInitDone"];
	
}

- (void) readData
{
	//[self addCmdToQueue:@"++ShipRecords"];
}

- (id) statusForKey:(id)aKey
{
	id aValue = [statusDictionary objectForKey:aKey];
	if(!aValue) return @"-";
	else return aValue;
}

- (void) pollHardware
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	[self specialStatus];
	if(pollTime){
		[self performSelector:@selector(pollHardware) withObject:nil afterDelay:pollTime];
	}
}

- (int) numPoints
{
	return [dataPointArray count];
}

- (double) radonValue:(int)index
{
	if(index<[dataPointArray count]){
		return [(ORRad7DataPt*)[dataPointArray objectAtIndex:index] value];
	}
	else return 0;
}

- (double) radonTime:(int)index
{
	if(index<[dataPointArray count]){
		return (double)[[dataPointArray objectAtIndex:index] time];
	}
	else return 0;
}

- (double) rhValue:(int)index
{
	if(index<[dataPointArray count]){
		return (double)[[dataPointArray objectAtIndex:index] rh];
	}
	else return 0;
}

#pragma mark •••Bit Processing Protocol
- (void) processIsStarting
{
}

- (void) processIsStopping
{
}

//note that everything called by these routines MUST be threadsafe
- (void) startProcessCycle
{    
}

- (void) endProcessCycle
{
}

- (NSString*) identifier
{
	NSString* s;
 	@synchronized(self){
		s= [NSString stringWithFormat:@"Rad7,%d",[self uniqueIdNumber]];
	}
	return s;
}

- (NSString*) processingTitle
{
	NSString* s;
 	@synchronized(self){
		s= [self identifier];
	}
	return s;
}

- (double) convertedValue:(int)aChan
{
	double theValue;
	@synchronized(self){
		theValue = 	[[statusDictionary objectForKey:kRad7LastRadon] doubleValue];
	}
	return theValue;
}

- (double) maxValueForChan:(int)aChan
{
	double theValue;
	@synchronized(self){
		theValue = (double)[self maxRadon];
	}
	return theValue;
}

- (double) minValueForChan:(int)aChan
{
	return 0;
}

- (void) getAlarmRangeLow:(double*)theLowLimit high:(double*)theHighLimit channel:(int)channel
{
	@synchronized(self){
		*theLowLimit = -.001;
		*theHighLimit =  [self alarmLimit];
	}		
}

- (BOOL) processValue:(int)channel
{
	BOOL r;
	@synchronized(self){
		r = [[statusDictionary objectForKey:kRad7RunStatus] boolValue];
	}
	return r;
}

- (void) setProcessOutput:(int)channel value:(int)value
{
    //nothing to do
}


@end

@implementation ORRad7Model (private)
- (void) resetDataSet
{
	[self setDataPointArray:nil];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelUpdatePlot 
														object:self];
}

- (void) timeout
{
	//NSLog(@"Rad7 timeout: %@\n",lastRequest);
	NSLogError(@"Rad7",@"command timeout",nil);
	[cmdQueue removeAllObjects];
	[self setOperationState:kRad7Idle];
	[self setLastRequest:nil];
}
- (void) clearTempVerbose
{
	tempVerbose = NO;
}

- (void) goToNextCommand
{
	[self setLastRequest:nil];			 //clear the last request
	[self processOneCommandFromQueue];	 //do the next command in the queue
}

- (void) processOneCommandFromQueue
{
	if([cmdQueue count] == 0) return;
	NSString* aCmd = [[[cmdQueue objectAtIndex:0] retain] autorelease];
	[cmdQueue removeObjectAtIndex:0];
	if([aCmd isEqualToString:@"++StartHWInit"]){
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
		[self setOperationState:kRad7Initializing];
		[self goToNextCommand];
	}
	else if([aCmd isEqualToString:@"++StartGroup"]){
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
		[self setOperationState:kRad7ExecutingGroup];
		[self goToNextCommand];
	}
	else if([aCmd isEqualToString:@"++HWInitDone"] || 
			[aCmd isEqualToString:@"++HWReviewDone"]){
		if(pollTime)[self performSelector:@selector(pollHardware) withObject:nil afterDelay:pollTime];
		[self setOperationState:kRad7Idle];
		[self goToNextCommand];
	}
	else if([aCmd isEqualToString:@"++EndGroup"]){
		id runStateString = [statusDictionary objectForKey:kRad7RunStatus];
		
		if(!runStateString)								 [self setRunState:kRad7RunStateUnKnown];
		else if([runStateString isEqualToString:@"LIVE"])[self setRunState:kRad7RunStateCounting];
		else											 [self setRunState:kRad7RunStateStopped];
		[self setOperationState:kRad7Idle];
		if(pollTime)[self performSelector:@selector(pollHardware) withObject:nil afterDelay:pollTime];
		
		[[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelStatusChanged object:self];
		[self goToNextCommand];
	}
	else {
		[self setLastRequest:aCmd];
		if([aCmd isEqualToString:@"++DumpUser"])aCmd = @"SETUP REVIEW";
		else if(currentRequest == kSpecialStart){
			id runStatus = [statusDictionary objectForKey:kRad7RunStatus];
			if(!runStatus){
				aCmd = nil;
				[self setLastRequest:nil];
				NSLog(@"Rad7 start command ignored -- status is unknown\n");
			}
			else if(![runStatus isEqualToString:@"IDLE"]){
				aCmd = nil;
				[self setLastRequest:nil];
				NSLog(@"Rad7 start command ignored -- already counting\n");
			}
		}
		if(aCmd){
			aCmd = [aCmd stringByReplacingOccurrencesOfString:@"\n" withString:@""];
			aCmd = [aCmd stringByReplacingOccurrencesOfString:@"\r" withString:@""];
			aCmd = [aCmd stringByAppendingString:@"\r\n"];
			
			//NSLog(@"Rad7: writing: %@\n",aCmd);
			[self startTimeOut];
			[serialPort writeString:aCmd];
		}
		if(!lastRequest){
			[self performSelector:@selector(processOneCommandFromQueue) withObject:nil afterDelay:1];
		}
	}
}

- (void) process_response:(NSString*)theResponse
{	
	theResponse = [theResponse removeExtraSpaces];
	//NSLog(@"(%d) %@\n",requestCount,theResponse);
	if([theResponse rangeOfString:@"DURRIDGE"].location != NSNotFound){
		tempVerbose = NO;
		//special unsolidated response after power up
		NSLog(@"Rad7 going thru power up -- all queued commands cleared\n");
		[cmdQueue removeAllObjects];
		[self setLastRequest:@"PowerUpSequence"]; //fake a command
	}
	else if([theResponse rangeOfString:@"?ERR"].location != NSNotFound){
		tempVerbose = NO;
		[cmdQueue removeAllObjects];
		requestCount = 0;
		expectedCount= 1;
		currentRequest = kRad7CommErr;
		[self setOperationState:kRad7Idle];
		NSLog(@"Rad7 Comm Error. Flushing Cmd Queue.\n");
		id runStateString = [statusDictionary objectForKey:kRad7RunStatus];
		
		if(!runStateString)								 [self setRunState:kRad7RunStateUnKnown];
		else if([runStateString isEqualToString:@"LIVE"])[self setRunState:kRad7RunStateCounting];
		else											 [self setRunState:kRad7RunStateStopped];
		[self setOperationState:kRad7Idle];
		
		[[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelStatusChanged object:self];
	}
	else {
		//check for data dump
		NSArray* parts = [theResponse componentsSeparatedByString:@" "];
		if([parts count] == 23){
			
			[self handleDataRecord:theResponse];
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(goToNextCommand) object:nil];
			[self performSelector:@selector(goToNextCommand) withObject:nil afterDelay:2];
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(clearTempVerbose) object:nil];
			[self performSelector:@selector(clearTempVerbose) withObject:nil afterDelay:2];
		}
		else {
			switch(currentRequest){
				
				case kRad7PowerUp:
				case kSetupReview:
				case kDumpValues:
					[self handleSetupReview:theResponse lineNumber:requestCount];
				break;
					
				case kSetupMode:
				case kSetupPump:
				case kSetupThoron:
				case kSetupTone:
				case kSetupFormat:
				case kSetupUnits:
				case kSetupProtocol:
				case kSetupRecycle:
				case kSetupCycle:
					[self handleSetupParam:theResponse lineNumber:requestCount];
				break;
					
				case kDataErase:
				break;	
					
				case kDataFree:
					[self handleDataFree:theResponse lineNumber:requestCount];
				break;	
					
				case kDataCom:
					[self handleDataCom:theResponse lineNumber:requestCount];
				break;
					
				case kTestCom:
					[self handleTestCom:theResponse lineNumber:requestCount];
				break;	
					
				case kSpecialStatus:
					[self handleStatusInfo:theResponse lineNumber:requestCount];
				break;
			}
			
			requestCount++;
			
			if(requestCount == expectedCount){
				[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
				[self performSelector:@selector(goToNextCommand) withObject:nil afterDelay:waitTime];
			}
		}
	}
}

- (void) handleDataRecord:(NSString*)aLine
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	NSArray* parts = [aLine componentsSeparatedByString:@" "];
	if([parts count] >= 23){
		if(dataRecordCount == 0){
			[self setDataPointArray:[NSMutableArray array]];
			if(makeFile){
				[stopRunFilePath release];
				stopRunFilePath = [NSString stringWithFormat:@"~/Desktop/Rad7/Rad7_%d_%@",[self uniqueIdNumber],[NSDate date]];
				stopRunFilePath = [stopRunFilePath stringByExpandingTildeInPath];
				stopRunFilePath = [stopRunFilePath stringByReplacingOccurrencesOfString:@" " withString:@"_"];
				stopRunFilePath = [stopRunFilePath stringByReplacingOccurrencesOfString:@"-" withString:@"_"];
				stopRunFilePath = [stopRunFilePath stringByReplacingOccurrencesOfString:@":" withString:@"_"];
				NSRange r = [stopRunFilePath rangeOfString:@"__"];
				if(r.location!=NSNotFound)stopRunFilePath = [stopRunFilePath substringToIndex:r.location];
				[stopRunFilePath retain];
				NSLog(@"Rad 7 data logged to file: %@\n",stopRunFilePath);
			}
			if(verbose  || tempVerbose){
				unsigned int unitsWord = [[parts objectAtIndex:22] intValue] & 0x3; //Units
				NSString* unitsString = @"";
				if(unitsWord == 0x0)unitsString = @"CPM";
				else if(unitsWord == 0x1)unitsString = @"#Counts";
				else if(unitsWord == 0x2)unitsString = @"Bq/m^3";
				else if(unitsWord == 0x3)unitsString = @"pCi/L";

				NSLogFont([NSFont fontWithName:@"Monaco" size:11], @"Cycle Date   Time  Counts  LT  A(%%)  B(%%)  C(%%)  D(%%)    Radon (%@)\n",unitsString);
				NSLogFont([NSFont fontWithName:@"Monaco" size:11], @"----------------------------------------------------------------------------\n");
			}
		}
		NSString* s = [NSString stringWithFormat:@"%3d %02d/%02d/%02d %02d:%02d %4d %5.1f %5.1f %5.1f %5.1f %5.1f %9.4f +- %9.4f",
					   [[parts objectAtIndex:0] intValue], //test number
					   [[parts objectAtIndex:3] intValue], //day
					   [[parts objectAtIndex:2] intValue], //month
					   [[parts objectAtIndex:1] intValue], //year
					   [[parts objectAtIndex:4] intValue], //hour
					   [[parts objectAtIndex:5] intValue], //minutes
					   [[parts objectAtIndex:6] intValue], //Total Counts
					   [[parts objectAtIndex:7] floatValue], //Live Time
					   [[parts objectAtIndex:8] floatValue], //% in A
					   [[parts objectAtIndex:9] floatValue], //% in B
					   [[parts objectAtIndex:10] floatValue], //% in C
					   [[parts objectAtIndex:11] floatValue], //% in C
					   [[parts objectAtIndex:20] floatValue], //Radon
					   [[parts objectAtIndex:21] floatValue] //UnCertainty
					   ];
		if(verbose || tempVerbose){			
			NSLogFont([NSFont fontWithName:@"Monaco" size:11], @"%@\n",s);
		}
		
		if(makeFile){
			//reformat for file
			s = [s removeExtraSpaces];
			s = [s stringByReplacingOccurrencesOfString:@" " withString:@","];
			s = [s stringByReplacingOccurrencesOfString:@",+-," withString:@","];
			
			NSFileManager* fm = [NSFileManager defaultManager];
			
			if(![fm fileExistsAtPath:stopRunFilePath]){
				NSString* dirPath = [stopRunFilePath stringByDeletingLastPathComponent];
				[fm createDirectoryAtPath:dirPath withIntermediateDirectories:YES attributes:nil error:nil];        
				[fm createFileAtPath:stopRunFilePath contents:nil attributes:nil];
			}
			NSFileHandle* fh = [NSFileHandle fileHandleForUpdatingAtPath:stopRunFilePath];
			[fh seekToEndOfFile];
			s = [s stringByAppendingString:@"\n"];
			[fh writeData:[s dataUsingEncoding:NSASCIIStringEncoding]];
			[fh closeFile];
		}
		
		dataRecordCount++;
		ORRad7DataPt* aPt = [[[ORRad7DataPt alloc] init] autorelease];
		[aPt setTime:[self convertTime:parts]];
		[aPt setValue:[[parts objectAtIndex:20] doubleValue]];
		//[aPt setCounts:[[parts objectAtIndex:6] doubleValue]];
		[aPt setRh:[[parts objectAtIndex:15] doubleValue]];
		[dataPointArray addObject:aPt];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelUpdatePlot 
															object:self];
	}
}

- (double) convertTime:(NSArray*)parts
{
	int day = [[parts objectAtIndex:3] intValue]; //day
	int month = [[parts objectAtIndex:2] intValue]; //month
	int year = [[parts objectAtIndex:1] intValue]; //year
	int hour = [[parts objectAtIndex:4] intValue]; //hour
	int minute = [[parts objectAtIndex:5] intValue]; //minutes
	NSString *dateStr = [NSString stringWithFormat:@"20%02d%02d%02d %02d:%02d",year,month,day,hour,minute];
	
	// Convert string to date object
	NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];
	[dateFormat setDateFormat:@"yyyyMMdd HH:mm"];
	NSDate *date = [dateFormat dateFromString:dateStr];  
	NSTimeInterval t1 = [date timeIntervalSince1970];
	[dateFormat release];
	return (double)t1;
}



- (void) handleSetupParam:(NSString*)aLine lineNumber:(int) lineNumber
{
	// nothing to do for now
}

- (void) handleTestCom:(NSString*)aLine lineNumber:(int) lineNumber
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	if(lineNumber == 1){
		NSLog(@"Rad7: Incomplete Test Data Follows\n");		
		//[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
		dataRecordCount = 0;
	}
}

- (void) handleDataCom:(NSString*)aLine lineNumber:(int) lineNumber
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	if(lineNumber == 2){
		NSLog(@"Rad7: %@\n",aLine);		
		//[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
		if([aLine rangeOfString:@"DATA TRANSFER"].location != NSNotFound){
			dataRecordCount = 0;
		}
	}
}

- (void) handleDataFree:(NSString*)aLine lineNumber:(int) lineNumber
{
	if(!statusDictionary) statusDictionary = [[NSMutableDictionary dictionary] retain];
	if(lineNumber == 2){
		if([aLine rangeOfString:@"CYCLES FREE"].location != NSNotFound){
			int freeCycles = [aLine intValue];
			[statusDictionary setObject:[NSNumber numberWithInt:freeCycles] forKey:kRad7FreeCycles];
		}
	}
}

- (void) handleStatusInfo:(NSString*)aLine lineNumber:(int) lineNumber
{
	if(!statusDictionary) statusDictionary = [[NSMutableDictionary dictionary] retain];
	if(lineNumber < 2)return; //don't care about these
	else if(lineNumber == 2){
		//arghhh -- some of the states don't have spaces between the fields
		aLine = [aLine stringByReplacingOccurrencesOfString:@"WAT-40" withString:@"WAT40 "];
		aLine = [aLine stringByReplacingOccurrencesOfString:@"WAT250" withString:@"WAT250 "];
		aLine = [aLine stringByReplacingOccurrencesOfString:@"NORMAL" withString:@"NORMAL "];
		aLine = [aLine removeExtraSpaces];
		NSArray* parts = [aLine componentsSeparatedByString:@" "];
		if([parts count] == 5){
			int thisRunNum = [[[parts objectAtIndex:0] substringToIndex:2] intValue];
			int thisCycleNum = [[[parts objectAtIndex:0] substringFromIndex:2] intValue];
			id lastRunStatus = [self statusForKey:kRad7RunStatus];
			id newRunStatus  = [parts objectAtIndex:1];
			if(lastRunStatus && newRunStatus && ![lastRunStatus isEqualToString:newRunStatus] && ![lastRunStatus isEqualToString:@"-"]){
				if([lastRunStatus length] && [newRunStatus isEqualToString:@"IDLE"]){
					runEnded = YES;
				}
			}
			[statusDictionary setObject:[NSNumber numberWithInt:thisRunNum]    forKey:kRad7RunNumber];
			[statusDictionary setObject:[NSNumber numberWithInt:thisCycleNum]  forKey:kRad7CycleNumber];
			[statusDictionary setObject:[parts objectAtIndex:1] forKey:kRad7RunStatus];
			[statusDictionary setObject:[parts objectAtIndex:2] forKey:kRad7RunPumpStatus];
			[statusDictionary setObject:[parts objectAtIndex:3] forKey:kRad7RunCountDown];
			[statusDictionary setObject:[parts objectAtIndex:4] forKey:kRad7NumberCounts];
		}
		else {
			[statusDictionary setObject:@"--" forKey:kRad7CycleNumber];
			[statusDictionary setObject:@"--" forKey:kRad7RunStatus];
			[statusDictionary setObject:@"--" forKey:kRad7RunPumpStatus];
			[statusDictionary setObject:@"--" forKey:kRad7RunCountDown];
			[statusDictionary setObject:@"--" forKey:kRad7NumberCounts];
		}
	}
	
	else if(lineNumber == 3){
		if([aLine hasPrefix:@"LAST READING: "]){
			aLine = [aLine substringFromIndex:14];
			if([aLine rangeOfString:@"NO TESTS STORED"].location == NSNotFound){
				aLine = [aLine stringByReplacingOccurrencesOfString:@"+- " withString:@"+-"];
				aLine = [aLine stringByReplacingOccurrencesOfString:@" +-" withString:@"+-"];

				NSArray* parts = [aLine componentsSeparatedByString:@" "];
				if([parts count] >= 3){
					int thisRunNum = [[[parts objectAtIndex:0] substringToIndex:2] intValue];
					int thisCycleNum = [[[parts objectAtIndex:0] substringFromIndex:2] intValue];
					int lastRunNum = [[statusDictionary objectForKey:kRad7LastRunNumber] intValue];
					int lastCycleNum = [[statusDictionary objectForKey:kRad7LastCycleNumber] intValue];
					
					[statusDictionary setObject:[[parts objectAtIndex:0] substringToIndex:2]    forKey:kRad7LastRunNumber];
					[statusDictionary setObject:[[parts objectAtIndex:0] substringFromIndex:2]  forKey:kRad7LastCycleNumber];
					NSArray* readingParts = [[parts objectAtIndex:1] componentsSeparatedByString:@"+-"];
					if([readingParts count] >= 2){
						float lastRadon        = [[readingParts objectAtIndex:0] floatValue];
						float lastUncertainty  = [[readingParts objectAtIndex:1] floatValue];
						[statusDictionary setObject:[NSNumber numberWithFloat:lastRadon]  forKey:kRad7LastRadon];
						[statusDictionary setObject:[NSNumber numberWithFloat:lastUncertainty]  forKey:kRad7LastRadonUncertainty];

						if(thisRunNum!=lastRunNum || thisCycleNum!=lastCycleNum){
							if(!dataPointArray){
								[self setDataPointArray:[NSMutableArray array]];
							}
							ORRad7DataPt* aPt = [[[ORRad7DataPt alloc] init] autorelease];
							NSDate *date = [NSDate date];  
							NSTimeInterval t1 = [date timeIntervalSince1970];

							[aPt setTime:t1];
							[aPt setValue:lastRadon];
							[aPt setRh:    [[self statusForKey:kRad7RH] floatValue]];
							[dataPointArray addObject:aPt];
							[[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelUpdatePlot 
																				object:self];
						}
					}
					[statusDictionary setObject:[parts objectAtIndex:2]  forKey:kRad7LastRadonUnits];
				}
			}
			else {
				[statusDictionary setObject:@"--"  forKey:kRad7LastRunNumber];
				[statusDictionary setObject:@"--"  forKey:kRad7LastCycleNumber];
				[statusDictionary setObject:@"--"  forKey:kRad7LastRadon];
				[statusDictionary setObject:@"--"  forKey:kRad7LastRadonUncertainty];
				[statusDictionary setObject:@"-"  forKey:kRad7LastRadonUnits];
			}
		}
	}
	
	else if(lineNumber == 4){
		aLine = [aLine stringByReplacingOccurrencesOfString:@": " withString:@":"];
		NSArray* parts = [aLine componentsSeparatedByString:@" "];
		if([parts count] == 4){
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:0] separator:@"`"] forKey:kRad7Temp];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:1] separator:@":" numberIndex:1] forKey:kRad7RH];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:2] separator:@":" numberIndex:1] forKey:kRad7Battery];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:3] separator:@":" numberIndex:1] forKey:kRad7PumpCurrent];
			NSArray* temperatureParts = [[parts objectAtIndex:0] componentsSeparatedByString:@"`"];
			if([temperatureParts count]==2)[statusDictionary setObject:[temperatureParts objectAtIndex:1] forKey:kRad7TempUnits];
			else [statusDictionary setObject:@"" forKey:kRad7TempUnits];
		}
		else {
			[statusDictionary setObject:@"--" forKey:kRad7Temp];
			[statusDictionary setObject:@"--" forKey:kRad7RH];
			[statusDictionary setObject:@"--" forKey:kRad7Battery];
			[statusDictionary setObject:@"--" forKey:kRad7PumpCurrent];
		}
	}
		
	else if(lineNumber == 5){
		aLine = [aLine stringByReplacingOccurrencesOfString:@": " withString:@":"];
		NSArray* parts = [aLine componentsSeparatedByString:@" "];
		if([parts count] == 4){
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:0] separator:@":" numberIndex:1] forKey:kRad7HV];
			[statusDictionary setObject:[NSNumber numberWithInt:[[parts objectAtIndex:1] intValue]] forKey:kRad7DutyCycle];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:2] separator:@":" numberIndex:1] forKey:kRad7LeakageCurrent];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:3] separator:@":" numberIndex:1] forKey:kRad7SignalVoltage];
			if(runEnded){
				if(verbose || makeFile  || tempVerbose){
					int theRunNumber = [[self statusForKey:kRad7LastRunNumber] intValue];
					if(theRunNumber>=1){
						[self printRun:theRunNumber];
					}
					else {
						NSLog(@"Rad7: No data available\n");
					}
				}
				runEnded = NO;
			}
		}
		else {
			[statusDictionary setObject:@"--" forKey:kRad7Temp];
			[statusDictionary setObject:@"--" forKey:kRad7RH];
			[statusDictionary setObject:@"--" forKey:kRad7Battery];
			[statusDictionary setObject:@"--" forKey:kRad7PumpCurrent];
		}
	}
}

- (NSNumber*) getNumber:(NSString*)aString separator:(NSString*)aSeparator
{
	return [self getNumber:aString separator:aSeparator numberIndex:0];
}

- (NSNumber*) getNumber:(NSString*)aString separator:(NSString*)aSeparator numberIndex:(int)anIndex
{
	NSArray* parts = [aString componentsSeparatedByString:aSeparator];
	if([parts count] >= anIndex){
		return [NSNumber numberWithFloat:[[parts objectAtIndex:anIndex] floatValue]];
	}
	else return [NSNumber numberWithInt:0];

}

- (void) handleSetupReview:(NSString*)aLine lineNumber:(int) lineNumber
{
	if(lineNumber < 4)return; //don't care about these
	if([aLine rangeOfString:@":"].location != NSNotFound){
		NSArray* parts = [aLine componentsSeparatedByString:@":"];
		if([parts count]>=2){
			NSString* tag   = [[parts objectAtIndex:0] trimSpacesFromEnds];
			NSString* value = [[parts objectAtIndex:1] trimSpacesFromEnds];
			NSString* value1 = @"";
			if([parts count]>=3)value1 = [[parts objectAtIndex:2] trimSpacesFromEnds];
			if(currentRequest == kDumpValues){
				if([tag isEqualToString:@"CYCLE"])			NSLog(@"Cycle: %@:%@\n",value,value1);
				else if([tag isEqualToString:@"RECYCLE"])	NSLog(@"Recycle: %@\n",value);
				else if([tag isEqualToString:@"MODE"])		NSLog(@"Mode: %@\n",value);
				else if([tag isEqualToString:@"THORON"])	NSLog(@"Thoron: %@\n",value);
				else if([tag isEqualToString:@"PUMP"])		NSLog(@"Pump Mode: %@\n",value);
			}
			else {
				if([tag isEqualToString:@"PUMP"])[self setPumpMode:[self convertPumpModeStringToIndex:value]];
				else if([tag isEqualToString:@"MODE"])[self setMode:[self convertModeStringToIndex:value]];
				else if([tag isEqualToString:@"THORON"])[self setThoron:[self convertThoronStringToIndex:value]];
				else if([tag isEqualToString:@"RECYCLE"])[self setRecycle:[value intValue]];
				else if([tag isEqualToString:@"CYCLE"])[self setCycleTime:[self convertCycleHours:value minutes:value1]];
				else if([tag isEqualToString:@"TONE"])[self setTone:[self convertToneStringToIndex:value]];
				else if([tag isEqualToString:@"FORMAT"])[self setFormatSetting:[self convertFormatStringToIndex:value]];
				else if([tag isEqualToString:@"PROTOCOL"])[self setProtocol:[self convertProtocolStringToIndex:value]];
				else if([tag isEqualToString:@"UNITS"])[self convertUnitsString:value];
			}
		}
		
	}
}

- (void) startTimeOut
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	[self performSelector:@selector(timeout) withObject:nil afterDelay:kRad7CmdTimeout];
}
@end

@implementation ORRad7DataPt
@synthesize value,time,rh;
@end
